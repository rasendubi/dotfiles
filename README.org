#+PROPERTY: header-args :tangle yes :noweb yes :results silent

* Introduction
Hi there! That's my dotfiles.

This repository contains configuration for three hosts:
- omicron — my main laptop which runs NixOS
- pie — my home server RPi running NixOS (see [[./pie.org][pie.org]])
- AlexeyShmalko — my work laptop running Ubuntu (ugh, corporate policies) with home-manager on top

Most of config files are generated by [[http://orgmode.org/worg/org-contrib/babel/][org-babel]] from org files in this repository (yes, including this very same ~README.org~). That's [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] applied to dotfiles.

This file contains Emacs configuration, NixOS configuration for omicron, and common home-manager configuration between omicron and AlexeyShmalko. (I try to keep repetition to minimum, but some is inevitable.)

[[./work.nix][work.nix]] file contains home-manager configuration specific for AlexeyShmalko.

[[./pie.org][pie.org]] is a separate NixOS config for pie host.

To generate actual nix files, you can open this file in Emacs, and execute =M-x org-babel-tangle=. Or from command line with the following command.

#+begin_src sh :tangle no
emacs README.org --batch -f org-babel-tangle
#+end_src

#+RESULTS:

Note that you need to patch org-babel to correctly generate configs (<<patch-ob-tangle>>)

I keep generated files in sync with org files (so this repo is a valid Nix Flake), but they are not worth looking at—you'll have much better time reading this doc instead.

Pieces not (yet) covered in org files are:
- scripts at =bin/=

* Table of Contents :TOC_3:
- [[#introduction][Introduction]]
- [[#top-level][Top-level]]
  - [[#flake][Flake]]
  - [[#stable-packages][Stable packages]]
  - [[#nixos][NixOS]]
  - [[#home-manager][Home manager]]
  - [[#packages][Packages]]
  - [[#overlays][Overlays]]
- [[#nixos-1][NixOS]]
  - [[#general][General]]
  - [[#re-expose-nixpkgs][Re-expose nixpkgs]]
  - [[#sandbox][Sandbox]]
  - [[#users][Users]]
  - [[#machines][Machines]]
    - [[#omicron][omicron]]
- [[#emacs][Emacs]]
  - [[#install-emacs][Install Emacs]]
  - [[#bootstrap-emacs-config][Bootstrap Emacs config]]
  - [[#patch-ob-tangle][Patch ob-tangle]]
  - [[#gc-hacks][GC hacks]]
  - [[#use-package][use-package]]
  - [[#package][package]]
  - [[#general-package][General (package)]]
  - [[#dont-clutter-system][Don't clutter system]]
  - [[#helpers][Helpers]]
  - [[#ivy][ivy]]
  - [[#smex][smex]]
  - [[#counsel][counsel]]
  - [[#avy][avy]]
  - [[#imenu--imenu-list][imenu / imenu-list]]
  - [[#wgrep][wgrep]]
  - [[#whitespace][whitespace]]
  - [[#whitespace-cleanup][whitespace-cleanup]]
  - [[#which-key][which-key]]
  - [[#google-translate][Google translate]]
  - [[#tab-bar-mode][tab-bar-mode]]
  - [[#highlight-current-line][Highlight current line]]
  - [[#scrolling][Scrolling]]
  - [[#visual-fill-column][visual-fill-column]]
  - [[#misc][Misc]]
- [[#environment][Environment]]
  - [[#exwm][EXWM]]
  - [[#window-management][Window management]]
  - [[#window-layout][Window layout]]
  - [[#screen-locking][Screen locking]]
    - [[#slock][Slock]]
    - [[#xss-lock][xss-lock]]
    - [[#exwm-integration][EXWM integration]]
  - [[#system-tray][System tray]]
  - [[#screenshots][Screenshots]]
  - [[#misc-1][Misc]]
- [[#input][Input]]
  - [[#keyboard][Keyboard]]
    - [[#workman][Workman]]
    - [[#keyboard-layout][Keyboard layout]]
    - [[#xkeymap][Xkeymap]]
    - [[#emacs-quail][Emacs quail]]
  - [[#mouse][Mouse]]
    - [[#python-listener][Python listener]]
    - [[#emacs-handler][Emacs handler]]
- [[#network][Network]]
  - [[#networkmanager][NetworkManager]]
  - [[#vpn][VPN]]
  - [[#ssh][SSH]]
    - [[#mosh][Mosh]]
  - [[#dnsmasq][dnsmasq]]
  - [[#firewall][Firewall]]
- [[#services][Services]]
  - [[#locate][Locate]]
  - [[#gitolite][Gitolite]]
  - [[#syncthing][Syncthing]]
  - [[#docker][Docker]]
  - [[#backup][Backup]]
  - [[#direnv--lorri][direnv + lorri]]
- [[#hardware][Hardware]]
  - [[#autorandr][Autorandr]]
  - [[#screen-brightness][Screen brightness]]
  - [[#redshift][Redshift]]
  - [[#pulseaudio][PulseAudio]]
  - [[#bluetooth][Bluetooth]]
  - [[#adb][ADB]]
  - [[#fwupd][fwupd]]
- [[#browsers][Browsers]]
  - [[#tridactyl][Tridactyl]]
  - [[#edit-text-in-browser][Edit text in browser]]
  - [[#online-banking][Online banking]]
- [[#evil-mode][Evil-mode]]
  - [[#general-1][General]]
  - [[#swap-k-and-j][Swap k and j]]
  - [[#evil-numbers][evil-numbers]]
  - [[#evil-collection][evil-collection]]
  - [[#evil-surrond][evil-surrond]]
  - [[#calc][calc]]
  - [[#evilify-compile-mode][Evilify compile mode]]
  - [[#evilify-minibuffer][Evilify minibuffer]]
  - [[#evilify-shell-mode][Evilify shell mode]]
  - [[#lispyville][lispyville]]
- [[#org-mode][Org-mode]]
  - [[#general-2][General]]
  - [[#drill][Drill]]
  - [[#todo][Todo]]
  - [[#clocking][Clocking]]
  - [[#capture][Capture]]
    - [[#org-capture-keybindings][org-capture keybindings]]
  - [[#capturing-images][Capturing images]]
  - [[#datetree][datetree]]
  - [[#cliplink][cliplink]]
  - [[#refile][Refile]]
    - [[#refiling-with-hydras][Refiling with hydras]]
    - [[#refile-last-but-before-archive][Refile last but *before* archive]]
  - [[#archive][Archive]]
  - [[#agenda][Agenda]]
    - [[#allow-next-projects-to-stuck][Allow NEXT projects to stuck]]
  - [[#babel][Babel]]
  - [[#latex-preview][Latex preview]]
  - [[#image-preview][Image preview]]
  - [[#export][Export]]
  - [[#crypt][Crypt]]
  - [[#habits][Habits]]
  - [[#adaptive-wrap][adaptive-wrap]]
  - [[#org-roam][org-roam]]
  - [[#org-ref][org-ref]]
  - [[#org-roam-bibtex][org-roam-bibtex]]
  - [[#toc-org][toc-org]]
  - [[#org-fc][org-fc]]
  - [[#org-fc-review-todos][org-fc review todos]]
  - [[#toggle-markupview][toggle markup/view]]
  - [[#evilify-org-mode][Evilify org-mode]]
- [[#mail-setup][Mail setup]]
  - [[#applications][Applications]]
  - [[#interface][Interface]]
  - [[#emacs-1][Emacs]]
- [[#applications-1][Applications]]
  - [[#gpg][GPG]]
  - [[#yubikey][Yubikey]]
  - [[#password-store][password-store]]
  - [[#kde-apps][KDE apps]]
  - [[#zathura][Zathura]]
  - [[#user-applications][User applications]]
- [[#development][Development]]
  - [[#vim][Vim]]
  - [[#terminal--shell][Terminal / shell]]
    - [[#rxvt-unicode][rxvt-unicode]]
    - [[#vterm][vterm]]
    - [[#fish][fish]]
    - [[#eshell][eshell]]
    - [[#tmux][tmux]]
    - [[#other-terminal-goodies][Other terminal goodies]]
  - [[#git][git]]
    - [[#git-config][git config]]
    - [[#magit][magit]]
    - [[#git-commit][git-commit]]
    - [[#diff-hl][diff-hl]]
  - [[#man-pages][Man pages]]
  - [[#emacs-2][Emacs]]
    - [[#use-spaces-for-indentation][Use spaces for indentation]]
    - [[#make-underscore-part-of-words][Make underscore part of words]]
    - [[#color-compilation-mode][Color compilation mode]]
    - [[#projectile][projectile]]
    - [[#company][company]]
    - [[#hippie-expand][Hippie expand]]
    - [[#flycheck][flycheck]]
    - [[#flycheck-inline][flycheck-inline]]
    - [[#electric-pair][electric-pair]]
    - [[#color-identifiers][Color identifiers]]
    - [[#dtrt-indent][dtrt-indent]]
    - [[#paren-face][paren-face]]
    - [[#lsp][LSP]]
    - [[#commenting][Commenting]]
    - [[#yasnippet][yasnippet]]
  - [[#languages][Languages]]
    - [[#emacs-lisp][Emacs lisp]]
    - [[#nix][Nix]]
    - [[#haskell][Haskell]]
    - [[#rust][Rust]]
    - [[#go][Go]]
    - [[#cc][C/C++]]
    - [[#cmake][CMake]]
    - [[#python][Python]]
    - [[#javascript][JavaScript]]
    - [[#typescript][Typescript]]
    - [[#vue][Vue]]
    - [[#web-mode][Web-mode]]
    - [[#clojurescript][Clojure(Script)]]
    - [[#racket][Racket]]
    - [[#groovy][Groovy]]
    - [[#kotlin][Kotlin]]
    - [[#forth][Forth]]
    - [[#lua][Lua]]
    - [[#ledger--hledger][Ledger / Hledger]]
    - [[#markdown][Markdown]]
    - [[#json][JSON]]
    - [[#yaml][YAML]]
    - [[#jinja2][Jinja2]]
    - [[#docker-1][Docker]]
    - [[#restclient][restclient]]
    - [[#terraform][terraform]]
    - [[#graphviz][graphviz]]
    - [[#protobuf][protobuf]]
    - [[#sql][SQL]]
    - [[#plantuml][PlantUML]]
  - [[#android][Android]]
- [[#look-and-feel][Look and Feel]]
  - [[#remove-the-clutter][Remove the clutter]]
  - [[#beacon-mode][beacon-mode]]
  - [[#fonts][Fonts]]
  - [[#custom-input-font][Custom Input font]]
  - [[#variable-pitch-fonts-in-org-mode][Variable-pitch fonts in org-mode]]
  - [[#hi-dpi][Hi-DPI]]
  - [[#color-theme][Color theme]]
  - [[#emacs-modeline][Emacs modeline]]
- [[#misc-2][Misc]]
  - [[#goto-config][goto config]]
  - [[#configure-path][Configure PATH]]

* Top-level
** Flake
This repository is nix flakes–compatible.

The following goes to ~flake.nix~ file.
#+begin_src nix :tangle flake.nix :noweb no-export :padline no
#
# This file is auto-generated from "README.org"
#
{
  description = "rasendubi's packages and NixOS/home-manager configurations";

  inputs = {
    nixpkgs = {
      type = "github";
      owner = "NixOS";
      repo = "nixpkgs";
      ref = "nixpkgs-unstable";
    };

    <<flake-inputs>>
  };

  outputs = { self, ... }@inputs:
    let
      # Flakes are evaluated hermetically, thus are unable to access
      # host environment (including looking up current system).
      #
      # That's why flakes must explicitly export sets for each system
      # supported.
      systems = ["x86_64-linux" "aarch64-linux"];

      # genAttrs applies f to all elements of a list of strings, and
      # returns an attrset { name -> result }
      #
      # Useful for generating sets for all systems or hosts.
      genAttrs = list: f: inputs.nixpkgs.lib.genAttrs list f;

      # Generate pkgs set for each system. This takes into account my
      # nixpkgs config (allowUnfree) and my overlays.
      pkgsBySystem =
        let mkPkgs = system: import inputs.nixpkgs {
              inherit system;
              overlays = self.overlays.${system};
              config = { allowUnfree = true; };
            };
        in genAttrs systems mkPkgs;

      # genHosts takes an attrset { name -> options } and calls mkHost
      # with options+name. The result is accumulated into an attrset
      # { name -> result }.
      #
      # Used in NixOS and Home Manager configurations.
      genHosts = hosts: mkHost:
        genAttrs (builtins.attrNames hosts) (name: mkHost ({ inherit name; } // hosts.${name}));

      # merges a list of attrsets into a single attrset
      mergeSections = inputs.nixpkgs.lib.foldr inputs.nixpkgs.lib.mergeAttrs {};

    in mergeSections [
      <<flake-outputs-nixos>>
      <<flake-outputs-home-manager>>
      <<flake-outputs-packages>>
      <<flake-outputs-overlays>>
    ];
}
#+end_src

Nix flakes are still an experimental feature, so you need the following in NixOS configuration to enable it.
#+name: nixos-section
#+begin_src nix
{
  nix = {
    package = pkgs.nixFlakes;
    extraOptions = ''
      experimental-features = nix-command flakes ca-references
    '';
  };
}
#+end_src

For non-NixOS system, install ~nixFlakes~ and put the following into =~/.config/nix/nix.conf=.
#+begin_src conf :tangle no
experimental-features = nix-command flakes ca-references
#+end_src

** Stable packages
For packages that are broken in nixpkgs-unstable, expose the latest stable channel as ~pkgs.stable~.

Add input:
#+name: flake-inputs
#+begin_src nix
nixpkgs-stable = {
  type = "github";
  owner = "NixOS";
  repo = "nixpkgs";
  ref = "nixos-20.03";
};
#+end_src

Add overlay:
#+name: flake-overlays
#+begin_src nix
(final: prev: {
  stable = import inputs.nixpkgs-stable {
    inherit system;
    overlays = self.overlays.${system};
    config = { allowUnfree = true; };
  };
})
#+end_src
** NixOS
Expose NixOS configurations.
#+name: flake-outputs-nixos
#+begin_src nix
(let
  nixosHosts = {
    omicron = { system = "x86_64-linux";  config = ./nixos-config.nix; };

    # pie uses a separate config as it is very different
    # from other hosts.
    pie =     { system = "aarch64-linux"; config = ./pie.nix; };
  };

  mkNixosConfiguration = { name, system, config }:
    let pkgs = pkgsBySystem.${system};
    in inputs.nixpkgs.lib.nixosSystem {
      inherit system;
      modules = [
        { nixpkgs = { inherit pkgs; }; }
        (import config)
      ];
      specialArgs = { inherit name inputs; };
    };

in {
  nixosConfigurations = genHosts nixosHosts mkNixosConfiguration;
})
#+end_src
** Home manager
Add home-manager to flake inputs.
#+name: flake-inputs
#+begin_src nix
home-manager = {
  type = "github";
  owner = "rycee";
  repo = "home-manager";
  ref = "master";
  inputs.nixpkgs.follows = "nixpkgs";
};
#+end_src

Expose home-manager configurations.
#+name: flake-outputs-home-manager
#+begin_src nix
(let
  homeManagerHosts = {
    AlexeyShmalko = {
      system = "x86_64-linux";
      config = ./work.nix;
      username = "rasen";
      homeDirectory = "/home/rasen";
    };
  };

  mkHomeManagerConfiguration = { system, name, config, username, homeDirectory }:
    let pkgs = pkgsBySystem.${system};
    in inputs.home-manager.lib.homeManagerConfiguration {
      inherit system pkgs username homeDirectory;
      configuration = { ... }: {
        nixpkgs.config.allowUnfree = true;
        nixpkgs.config.firefox.enableTridactylNative = true;
        nixpkgs.overlays = self.overlays.${system};
        imports = [
          self.lib.home-manager-common

          (import config)
        ];
      };
    };

in {
  # Re-export common home-manager configuration to be reused between
  # NixOS module and standalone home-manager config.
  lib.home-manager-common = { lib, pkgs, config, ... }: {
    imports = [
      <<home-manager-section>>
    ];
    home.stateVersion = "20.09";
  };
  homeManagerConfigurations = genHosts homeManagerHosts mkHomeManagerConfiguration;
})
#+end_src

Integrate home-manager module into NixOS.
#+name: nixos-section
#+begin_src nix
{
  imports = [inputs.home-manager.nixosModules.home-manager];
  home-manager = {
    useUserPackages = true;
    useGlobalPkgs = true;
    users.rasen = inputs.self.lib.home-manager-common;
  };
}
#+end_src

** Packages
Generate packages set for each supported system.
#+name: flake-outputs-packages
#+begin_src nix
(let
  mkPackages = system:
    let
      pkgs = pkgsBySystem.${system};
    in
      mergeSections [
        <<flake-packages>>
      ];

in {
  packages = genAttrs systems mkPackages;
})
#+end_src
** Overlays
Generate overlays for all supported systems.
#+name: flake-outputs-overlays
#+begin_src nix
(let
  mkOverlays = system: [
    # mix-in all local packages, so they are available as pkgs.${packages-name}
    (final: prev: self.packages.${system})

    <<flake-overlays>>
  ];
in {
  overlays = genAttrs systems mkOverlays;
})
#+end_src

~<<flake-overlays>>~ are defined elsewhere.
* NixOS
** General
I'm a [[http://nixos.org/][NixOS]] user. What's cool about it is that I can describe all my system configuration in one file (almost). I can execute a single command and have a system with the same software, system settings, etc.

An outline of configuration looks like this:

#+begin_src nix :tangle nixos-config.nix :noweb no-export :padline no
#
# This file is auto-generated from "README.org"
#
{ name, config, pkgs, lib, inputs, ... }:
let
  machine-config = lib.getAttr name {
    omicron = [
      <<machine-omicron>>
    ];
  };

in
{
  imports = [
    {
      nixpkgs.config.allowUnfree = true;

      # The NixOS release to be compatible with for stateful data such as databases.
      system.stateVersion = "19.09";
    }

    <<nixos-section>>
  ] ++ machine-config;
}
#+end_src

This =<<nixos-section>>= is replaced by other parts of this doc.

** Re-expose nixpkgs
#+name: nixos-section
#+begin_src nix
{
  # for compatibility with nix-shell, nix-build, etc.
  environment.etc.nixpkgs.source = inputs.nixpkgs;
  nix.nixPath = ["nixpkgs=/etc/nixpkgs"];

  # register self and nixpkgs as flakes for quick access
  nix.registry = {
    self.flake = inputs.self;

    nixpkgs = {
      from = { id = "nixpkgs"; type = "indirect"; };
      flake = inputs.nixpkgs;
    };
  };
}
#+end_src

Same but for Home Manager–managed host.
#+name: home-manager-section
#+begin_src nix
{
  home.file."nixpkgs".source = inputs.nixpkgs;
  systemd.user.sessionVariables.NIX_PATH = lib.mkForce "nixpkgs=$HOME/nixpkgs\${NIX_PATH:+:}$NIX_PATH";

  xdg.configFile."nix/registry.json".text = builtins.toJSON {
    version = 2;
    flakes = [
      {
        from = { id = "self"; type = "indirect"; };
        to = ({
          type = "path";
          path = inputs.self.outPath;
        } // lib.filterAttrs
          (n: v: n == "lastModified" || n == "rev" || n == "revCount" || n == "narHash")
          inputs.self);
      }
      {
        from = { id = "nixpkgs"; type = "indirect"; };
        to = ({
          type = "path";
          path = inputs.nixpkgs.outPath;
        } // lib.filterAttrs
          (n: v: n == "lastModified" || n == "rev" || n == "revCount" || n == "narHash")
          inputs.nixpkgs);
      }
    ];
  };
}
#+end_src
** Sandbox
Build all packages in sandbox:
#+name: nixos-section
#+begin_src nix
{
  nix.useSandbox = true;
}
#+end_src
** Users
I'm the only user of the system:

#+name: nixos-section
#+begin_src nix
{
  users.extraUsers.rasen = {
    isNormalUser = true;
    uid = 1000;
    extraGroups = [ "users" "wheel" ];
    initialPassword = "HelloWorld";
  };
  nix.trustedUsers = ["rasen"];
}
#+end_src

=initialPassword= is used only first time when user is created. It must be changed as soon as possible with =passwd=.

** Machines
*** omicron
This is my small Dell XPS 13.
#+name: machine-omicron
#+begin_src nix
{
  imports = [
    (import "${inputs.nixos-hardware}/dell/xps/13-9360")
    inputs.nixpkgs.nixosModules.notDetected
  ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "nvme" "usb_storage" "sd_mod" "rtsx_pci_sdmmc" ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ config.boot.kernelPackages.rtl88x2bu ];

  nix.maxJobs = lib.mkDefault 4;

  # powerManagement.cpuFreqGovernor = "powersave";

  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
}
#+end_src

~inputs.nixos-hardware~ comes from the following flake input.
#+name: flake-inputs
#+begin_src nix
nixos-hardware = {
  type = "github";
  owner = "NixOS";
  repo = "nixos-hardware";
  flake = false;
};
#+end_src

LVM on LUKS setup for disk encryption.
#+name: machine-omicron
#+begin_src nix
{
  boot.initrd.luks.devices = {
    root = {
      device = "/dev/disk/by-uuid/8b591c68-48cb-49f0-b4b5-2cdf14d583dc";
      preLVM = true;
    };
  };
  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/BA72-5382";
    fsType = "vfat";
  };
  fileSystems."/" = {
    device = "/dev/disk/by-uuid/434a4977-ea2c-44c0-b363-e7cf6e947f00";
    fsType = "ext4";
    options = [ "noatime" "nodiratime" "discard" ];
  };
  fileSystems."/home" = {
    device = "/dev/disk/by-uuid/8bfa73e5-c2f1-424e-9f5c-efb97090caf9";
    fsType = "ext4";
    options = [ "noatime" "nodiratime" "discard" ];
  };
  swapDevices = [
    { device = "/dev/disk/by-uuid/26a19f99-4f3a-4bd5-b2ed-359bed344b1e"; }
  ];
}
#+end_src

Clickpad:
#+name: machine-omicron
#+begin_src nix
{
  services.xserver.libinput = {
    enable = true;
    accelSpeed = "0.7";
  };
}
#+end_src
* Emacs
** Install Emacs
#+name: install-emacs

I use emacs-27 from [[https://github.com/nix-community/emacs-overlay][emacs-overlay]].
#+name: flake-inputs
#+begin_src nix
emacs-overlay = {
  type = "github";
  owner = "nix-community";
  repo = "emacs-overlay";
};
#+end_src

Use overlay (~<<flake-overlays>>~).
#+name: flake-overlays
#+begin_src nix
inputs.emacs-overlay.overlay
#+end_src

Expose Emacs with my packages as a top-level package (~<<flake-packages>>~).
#+name: flake-packages
#+begin_src nix
(let
  emacs-base = pkgs.emacsGit;
  # emacs = pkgs.emacsUnstable;
  # emacs = pkgs.emacs.override {
  #   # Build emacs with proper imagemagick support.
  #   # See https://github.com/NixOS/nixpkgs/issues/70631#issuecomment-570085306
  #   imagemagick = pkgs.imagemagickBig;
  # };
  emacs-packages = (epkgs:
    (with epkgs.melpaPackages; [

      aggressive-indent
      atomic-chrome
      avy
      bash-completion
      beacon
      blacken
      cider
      clojure-mode
      cmake-mode
      color-identifiers-mode
      company
      company-box
      company-lsp
      company-org-roam
      counsel
      counsel-projectile
      diff-hl
      diminish
      direnv
      dockerfile-mode
      doom-modeline
      dtrt-indent
      edit-indirect
      eglot
      el-patch
      elpy
      epresent
      evil
      evil-collection
      evil-magit
      evil-numbers
      evil-org
      evil-surround
      evil-swap-keys
      fish-completion
      fish-mode
      flycheck
      flycheck-inline
      flycheck-jest
      flycheck-rust
      forth-mode
      general
      gitconfig-mode
      go-mode
      google-translate
      graphviz-dot-mode
      groovy-mode
      haskell-mode
      imenu-list
      ivy
      ivy-bibtex
      ivy-pass
      jinja2-mode
      js2-mode
      json-mode
      ledger-mode
      lispyville
      lsp-haskell
      lsp-mode
      lsp-ui
      lua-mode
      magit
      markdown-mode
      modus-themes
      nix-mode
      nix-sandbox
      notmuch
      org-cliplink
      org-download
      org-drill
      org-ref
      org-roam
      org-roam-bibtex
      org-super-agenda
      paren-face
      pass
      php-mode
      pip-requirements
      plantuml-mode
      prettier-js
      projectile
      protobuf-mode
      psc-ide
      purescript-mode
      py-autopep8
      racer
      racket-mode
      restclient
      rjsx-mode
      rust-mode
      smex
      spaceline
      terraform-mode
      tide
      toc-org
      typescript-mode
      use-package
      visual-fill-column
      vterm
      vue-mode
      w3m
      web-mode
      wgrep
      which-key
      whitespace-cleanup-mode
      writegood-mode
      yaml-mode
      yasnippet

    ]) ++
    [
      epkgs.orgPackages.org-plus-contrib
      epkgs.elpaPackages.adaptive-wrap
      epkgs.exwm

      (epkgs.melpaBuild rec {
        pname = "org-fc";
        version = "20201002";
        src = pkgs.fetchFromGitHub {
          owner = "l3kn";
          repo = "org-fc";
          rev = "0fd72b4d9dcf82584b784bb7cf76d94109ee9bab";
          sha256 = "sha256-X01yELYog1bRJb1jAk77jbjDBvJxMVLoDsw+7S4lLec=";
        };
        packageRequires = [ epkgs.orgPackages.org-plus-contrib ];
        propagatedUserEnvPkgs = [ pkgs.findutils pkgs.gawk ];

        recipe = pkgs.writeText "recipe" ''
         (org-fc
          :repo "l3kn/org-fc"
          :fetcher github
          :files ("*.el" "demo.org" "awk"))
        '';

        meta = {
          description = "Spaced Repetition System for Emacs org-mode";
          license = pkgs.lib.licenses.gpl3;
        };
      })

      # required for org-roam/emacsql-sqlite3
      pkgs.sqlite

      (pkgs.ycmd.override (old: {
        # racerd is currently broken
        rustracerd = null;
      }))
      pkgs.notmuch
      pkgs.w3m
      pkgs.imagemagick
      pkgs.shellcheck

      (pkgs.python3.withPackages (pypkgs: [
        pypkgs.autopep8
        pypkgs.black
        pypkgs.flake8
        pypkgs.mypy
        pypkgs.pylint
        pypkgs.virtualenv
      ]))

      (pkgs.aspellWithDicts (dicts: with dicts; [en en-computers en-science ru uk]))

      # latex for displaying fragments in org-mode
      (pkgs.texlive.combine {
        inherit (pkgs.texlive) scheme-small dvipng dvisvgm mhchem tikz-cd ;
      })
      pkgs.ghostscript
    ]
  );

  emacs-final = (pkgs.emacsPackagesGen emacs-base).emacsWithPackages emacs-packages;

 in {
   my-emacs = emacs-final // {
     base = emacs-base;
     packages = emacs-packages;
   };
 })
#+end_src

Install Emacs with Home manager (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.emacs = {
    enable = true;
    package = pkgs.my-emacs.base;
    extraPackages = pkgs.my-emacs.packages;
  };
  services.emacs.enable = true;

  # fonts used by emacs
  home.packages = [
    pkgs.input-mono
    pkgs.libertine
  ];
}
#+end_src

** Bootstrap Emacs config
Besides tangling into Flake/NixOS configuration files, this file /is/ Emacs configuration.

Emacs does not source this file automatically, so I need to instruct it to do so.
Check [[https://orgmode.org/worg/org-contrib/babel/intro.html#emacs-initialization][org-babel documentation]] for more info.
The following snippet is an adaptation of that idea and goes to my ~.emacs.d/init.el~.
#+begin_src emacs-lisp :tangle .emacs.d/init.el
;;
;; This file is auto-generated from "README.org"
;;

(defvar rasen/dotfiles-directory
  (file-name-as-directory
   (expand-file-name ".." (file-name-directory (file-truename user-init-file))))
  "The path to the dotfiles directory.")

(require 'org)
(require 'ob-tangle)

<<ob-tangle-patch>>

(org-babel-load-file (expand-file-name "README.org" rasen/dotfiles-directory))
#+end_src

Another important file that needs to be tangled is [[./.emacs.d/early-init.el]]. For now, just add a header to it.
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
;;;
;;; This file is auto-generated from "README.org"
;;;
#+end_src
** Patch ob-tangle
#+name: patch-ob-tangle
*This patch is critical to getting this config working. Without it, org-babel will tangle this file incorrectly*

This patches ob-tangle to allow defining sections with the same name multiple times. All sections with the same name are concatenated. (This was the default behavior some time ago, so this restores it.)
(~<<ob-tangle-patch>>~)
#+name: ob-tangle-patch
#+begin_src emacs-lisp :noweb no
(require 'el-patch)
;; org-babel fixes to tangle ALL matching sections
(defun rasen/map-regex (regex fn)
  "Map the REGEX over the BUFFER executing FN.

FN is called with the match-data of the regex.

Returns the results of the FN as a list."
  (save-excursion
    (goto-char (point-min))
    (let (res)
      (save-match-data
        (while (re-search-forward regex nil t)
          (let ((f (match-data)))
            (setq res
                  (append res
                          (list
                           (save-match-data
                             (funcall fn f))))))))
      res)))

(el-patch-feature ob-core)
(el-patch-defun org-babel-expand-noweb-references (&optional info parent-buffer)
  "Expand Noweb references in the body of the current source code block.

For example the following reference would be replaced with the
body of the source-code block named `example-block'.

<<example-block>>

Note that any text preceding the <<foo>> construct on a line will
be interposed between the lines of the replacement text.  So for
example if <<foo>> is placed behind a comment, then the entire
replacement text will also be commented.

This function must be called from inside of the buffer containing
the source-code block which holds BODY.

In addition the following syntax can be used to insert the
results of evaluating the source-code block named `example-block'.

<<example-block()>>

Any optional arguments can be passed to example-block by placing
the arguments inside the parenthesis following the convention
defined by `org-babel-lob'.  For example

<<example-block(a=9)>>

would set the value of argument \"a\" equal to \"9\".  Note that
these arguments are not evaluated in the current source-code
block but are passed literally to the \"example-block\"."
  (let* ((parent-buffer (or parent-buffer (current-buffer)))
         (info (or info (org-babel-get-src-block-info 'light)))
         (lang (nth 0 info))
         (body (nth 1 info))
         (comment (string= "noweb" (cdr (assq :comments (nth 2 info)))))
         (noweb-re (format "\\(.*?\\)\\(%s\\)"
                           (with-current-buffer parent-buffer
                             (org-babel-noweb-wrap))))
         (cache nil)
         (c-wrap
          (lambda (s)
            ;; Comment string S, according to LANG mode.  Return new
            ;; string.
            (unless org-babel-tangle-uncomment-comments
              (with-temp-buffer
                (funcall (org-src-get-lang-mode lang))
                (comment-region (point)
                                (progn (insert s) (point)))
                (org-trim (buffer-string))))))
         (expand-body
          (lambda (i)
            ;; Expand body of code represented by block info I.
            (let ((b (if (org-babel-noweb-p (nth 2 i) :eval)
                         (org-babel-expand-noweb-references i)
                       (nth 1 i))))
              (if (not comment) b
                (let ((cs (org-babel-tangle-comment-links i)))
                  (concat (funcall c-wrap (car cs)) "\n"
                          b "\n"
                          (funcall c-wrap (cadr cs))))))))
         (expand-references
          (lambda (ref cache)
            (pcase (gethash ref cache)
              (`(,last . ,previous)
               ;; Ignore separator for last block.
               (let ((strings (list (funcall expand-body last))))
                 (dolist (i previous)
                   (let ((parameters (nth 2 i)))
                     ;; Since we're operating in reverse order, first
                     ;; push separator, then body.
                     (push (or (cdr (assq :noweb-sep parameters)) "\n")
                           strings)
                     (push (funcall expand-body i) strings)))
                 (mapconcat #'identity strings "")))
              ;; Raise an error about missing reference, or return the
              ;; empty string.
              ((guard (or org-babel-noweb-error-all-langs
                          (member lang org-babel-noweb-error-langs)))
               (error "Cannot resolve %s (see `org-babel-noweb-error-langs')"
                      (org-babel-noweb-wrap ref)))
              (_ "")))))
    (replace-regexp-in-string
     noweb-re
     (lambda (m)
       (with-current-buffer parent-buffer
         (save-match-data
           (let* ((prefix (match-string 1 m))
                  (id (match-string 3 m))
                  (evaluate (string-match-p "(.*)" id))
                  (expansion
                   (cond
                    (evaluate
                     ;; Evaluation can potentially modify the buffer
                     ;; and invalidate the cache: reset it.
                     (setq cache nil)
                     (let ((raw (org-babel-ref-resolve id)))
                       (if (stringp raw) raw (format "%S" raw))))
                    ;; Retrieve from the Library of Babel.
                    ((nth 2 (assoc-string id org-babel-library-of-babel)))
                    ;; Return the contents of headlines literally.
                    ((org-babel-ref-goto-headline-id id)
                     (org-babel-ref-headline-body))
                    ;; Look for a source block named SOURCE-NAME.  If
                    ;; found, assume it is unique; do not look after
                    ;; `:noweb-ref' header argument.
                    ((org-with-point-at 1
                       (let ((r (org-babel-named-src-block-regexp-for-name id)))
                         (and (re-search-forward r nil t)
                              (not (org-in-commented-heading-p))
                              (el-patch-swap
                                (funcall expand-body
                                         (org-babel-get-src-block-info t))
                                (mapconcat
                                 #'identity
                                 (rasen/map-regex r
                                                  (lambda (md)
                                                    (funcall expand-body
                                                             (org-babel-get-src-block-info t))))
                                 "\n"))))))
                    ;; All Noweb references were cached in a previous
                    ;; run.  Extract the information from the cache.
                    ((hash-table-p cache)
                     (funcall expand-references id cache))
                    ;; Though luck.  We go into the long process of
                    ;; checking each source block and expand those
                    ;; with a matching Noweb reference.  Since we're
                    ;; going to visit all source blocks in the
                    ;; document, cache information about them as well.
                    (t
                     (setq cache (make-hash-table :test #'equal))
                     (org-with-wide-buffer
                      (org-babel-map-src-blocks nil
                        (if (org-in-commented-heading-p)
                            (org-forward-heading-same-level nil t)
                          (let* ((info (org-babel-get-src-block-info t))
                                 (ref (cdr (assq :noweb-ref (nth 2 info)))))
                            (push info (gethash ref cache))))))
                     (funcall expand-references id cache)))))
             ;; Interpose PREFIX between every line.
             (mapconcat #'identity
                        (split-string expansion "[\n\r]")
                        (concat "\n" prefix))))))
     body t t 2)))
#+end_src
** GC hacks
Suppress GC in early init and restore it after init is complete. (~.emacs.d/early-init.el~)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(setq gc-cons-threshold most-positive-fixnum)
(add-hook 'emacs-startup-hook (defun rasen/restore-gc-threshold ()
                                (setq gc-cons-threshold 800000)))
#+end_src
** use-package
[[https://github.com/jwiegley/use-package][use-package]] is a cool emacs library that helps managing emacs configuration making it simpler and more structured. (emacs-lisp)
#+begin_src emacs-lisp
;; Do not ensure packages---they are installed with Nix
(setq use-package-always-ensure nil)
;; (setq use-package-verbose t)
(eval-when-compile
  (require 'use-package))
(require 'bind-key)
(require 'diminish)
#+end_src
** package
All emacs packages are installed with Nix. (See <<install-emacs>>.)
Disable usage of emacs internal archives. (~.emacs.d/early-init.el~)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(require 'package)
(setq package-archives nil)
(setq package-enable-at-startup nil)
#+end_src
** General (package)
I use [[https://github.com/noctuid/general.el][general]] to define my keybindings. (emacs-lisp)
#+begin_src emacs-lisp
(use-package general)

;; Definer for my leader
(general-create-definer --leader-def   :prefix "SPC")
(general-create-definer --s-leader-def :prefix "s-SPC" :non-normal-prefix "s-SPC")

;; Extra-hackery to define key with multiple prefixes
(defmacro leader-def (&rest args)
  (declare (indent defun))
  `(progn (--leader-def   ,@args)
          (--s-leader-def ,@args)))

;; Definer for my leader + applied globally across all windows.
(general-create-definer s-leader-def
  :keymaps '(motion) :prefix "SPC"
  :global-prefix "s-SPC")

(use-package evil
  :config
  ;; free-up prefix
  (s-leader-def :keymaps '(motion normal visual) "" nil))
#+end_src
** Don't clutter system
Save custom configuration in the =~/.emacs.d/custom.el= file so emacs does not clutter =init.el=.
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file t)
#+end_src

Don't clutter the current directory with backups. Save them in a separate directory.
#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

Don't clutter the current directory with auto-save files.
#+begin_src emacs-lisp
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/" t)))
#+end_src

Do not create lockfiles either. (I am the only user in the system and only use emacs through daemon, so that should be ok.)
#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src
** Helpers
Emacs lisp helper functions.

Timestamp-ids are used to uniquely identify things.
#+begin_src emacs-lisp
(defun rasen/tsid (&optional time)
  "Return timestamp-id."
  (format-time-string "%Y%m%d%H%M%S" time "UTC"))

(defun rasen/insert-tsid ()
  "Insert timestamp-id at point."
  (interactive)
  (insert (rasen/tsid)))
#+end_src

#+begin_src emacs-lisp
(defun rasen/copy-file-path ()
  "Copy the current buffer's path to kill ring."
  (interactive)
  ;; TODO: optionally strip project path
  (kill-new (buffer-file-name)))
#+end_src

#+begin_src emacs-lisp
(defun rasen/org-copy-log-entry (arg)
  "Copy the current org entry as a log line with timestamp.

The transformation is as follows:

,* I am entry
:PROPERTIES:
CREATED: [2020-06-01]
:END:

becomes

- [2020-06-01] I am entry

If ARG is provided, kill the entry."
  (interactive "P")
  (let* ((heading (org-get-heading))
         (created (org-entry-get (point) "CREATED"))
         (line (concat "- " created " " heading)))
    (when arg
      (org-cut-subtree)
      (current-kill 1))
    (kill-new (concat line "\n"))
    (message line)))
#+end_src

Shamelessly stolen from https://github.com/purcell/emacs.d.
#+begin_src emacs-lisp
(defun rename-this-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "FNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting file!" name))
    (if (get-buffer new-name)
        (message "A buffer named '%s' already exists!" new-name)
      (progn
        (when (file-exists-p filename)
          (rename-file filename new-name 1))
        (rename-buffer new-name)
        (set-visited-file-name new-name)))))

(defun delete-this-file-and-buffer ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-buffer)))
#+end_src

#+begin_src emacs-lisp
(defun add-to-path (str)
  "Add an STR to the PATH environment variable."
  (setenv "PATH" (concat str ":" (getenv "PATH"))))
#+end_src
** ivy
#+begin_src emacs-lisp
(use-package ivy
  :demand
  :general
  (s-leader-def
    "b"  #'ivy-switch-buffer)
  :diminish ivy-mode
  :config
  <<ivy-config>>
  )
#+end_src

Do not start input with =^= and ignore the case.
#+name: ivy-config
#+begin_src emacs-lisp
(setq-default ivy-initial-inputs-alist nil)
(setq-default ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
#+end_src

Do not show ~./~ and ~../~ during file name completion.
#+name: ivy-config
#+begin_src emacs-lisp
(setq-default ivy-extra-directories nil)
#+end_src

The normal =C-j= is not placed conveniently on Workman layout, so move its function to =C-e= (which is qwerty =k=).
#+name: ivy-config
#+begin_src emacs-lisp
(general-def 'ivy-minibuffer-map
  "C-e"   #'ivy-alt-done
  "C-M-e" #'ivy-immediate-done)
#+end_src

Evilify ivy-occur.
#+name: ivy-config
#+begin_src emacs-lisp
(general-def
  :keymaps '(ivy-occur-mode-map ivy-occur-grep-mode-map)
  :states 'normal
  "k"    #'ivy-occur-next-line
  "j"    #'ivy-occur-previous-line
  "C-n"  #'ivy-occur-next-line
  "C-p"  #'ivy-occur-previous-line
  "RET"  #'ivy-occur-press-and-switch
  "TAB"  #'ivy-occur-press
  "C-e"  #'ivy-occur-press-and-switch
  "g r"  #'ivy-occur-revert-buffer
  "g g"  #'evil-goto-first-line
  "d"    #'ivy-occur-delete-candidate
  "r"    #'read-only-mode
  "a"    #'ivy-occur-read-action
  "c"    #'ivy-occur-toggle-calling
  "f"    #'ivy-occur-press
  "o"    #'ivy-occur-dispatch
  "q"    #'quit-window)

(general-def 'normal 'ivy-occur-grep-mode-map
  "w"    #'ivy-wgrep-change-to-wgrep-mode)
#+end_src

Enable ivy.
#+name: ivy-config
#+begin_src emacs-lisp
(ivy-mode 1)
#+end_src
** smex
I use smex for improved =counsel-M-x= (show most frequently used commands first).
#+begin_src emacs-lisp
(use-package smex
  :config
  (smex-initialize))
#+end_src
** counsel
#+begin_src emacs-lisp
(use-package counsel
  :demand
  :diminish counsel-mode
  :general
  (s-leader-def
    "x"  #'counsel-M-x
    "f"  #'counsel-find-file)
  ('motion
   "g r"    #'counsel-git-grep
   "g /"    #'counsel-rg)
  ('read-expression-map
   "C-r"    #'counsel-expression-history)
  :config
  ;; reset ivy initial inputs for counsel
  (setq-default ivy-initial-inputs-alist nil)
  (counsel-mode 1))
#+end_src
** avy
Jump anywhere with a few keystrokes in tree-like way.
#+begin_src emacs-lisp
(use-package avy
  :bind
  :general
  ('motion
   "K"  #'avy-goto-char)
  :custom
  ;; easy workman keys (excluding pinky)
  (avy-keys '(?s ?h ?t ?n ?e ?o ?d ?r ?u ?p)))
#+end_src
** imenu / imenu-list
Use imenu to jump to symbols in the current buffer.
#+begin_src emacs-lisp
(use-package imenu-list
  :general
  (:keymaps 'imenu-list-major-mode-map
   :states 'normal
   "RET"       #'imenu-list-goto-entry
   "TAB"       #'imenu-list-display-entry
   "<backtab>" #'hs-toggle-hiding
   "g r"       #'imenu-list-refresh
   "q"         #'imenu-list-quit-window))
#+end_src

#+begin_src emacs-lisp
(defun rasen/imenu-or-list (arg)
  "Invoke `counsel-imenu'. If prefix is provided, toggle imenu-list"
  (interactive "P")
  (if arg
      (imenu-list-smart-toggle)
    (counsel-imenu)))

(leader-def 'motion  "g" #'rasen/imenu-or-list)
#+end_src
** wgrep
Edit grep buffers and apply changes to the files.
#+begin_src emacs-lisp
(use-package wgrep)
#+end_src
** whitespace
A good mode to highlight whitespace issues (leading/trailing spaces/newlines) and too long lines.
#+begin_src emacs-lisp
(use-package whitespace
  :diminish (global-whitespace-mode
             whitespace-mode
             whitespace-newline-mode)
  :hook (prog-mode . whitespace-mode)
  :config
  (setq-default whitespace-line-column 120
                whitespace-style '(face
                                   tab-mark
                                   empty
                                   trailing
                                   lines-tail)))
#+end_src
** whitespace-cleanup
Fix whitespaces on file save.
#+begin_src emacs-lisp
(use-package whitespace-cleanup-mode
  :diminish whitespace-cleanup-mode
  :config
  (global-whitespace-cleanup-mode 1))
#+end_src
** which-key
[[https://github.com/justbur/emacs-which-key][which-key]] is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.
#+begin_src emacs-lisp
(use-package which-key
  :defer 2
  :diminish which-key-mode
  :config
  (which-key-mode))
#+end_src
** Google translate
#+begin_src emacs-lisp
(use-package google-translate
  :general
  ('normal
   '(markdown-mode-map org-mode-map)
   "z g t" #'rasen/google-translate-at-point
   "z g T" #'google-translate-smooth-translate)

  :commands (google-translate-smooth-translate)
  :config
  (defun rasen/google-translate-at-point (arg)
    "Translate word at point. If prefix is provided, do reverse translation"
    (interactive "P")
    (if arg
        (google-translate-at-point-reverse)
      (google-translate-at-point)))

  (require 'google-translate-default-ui)
  (require 'google-translate-smooth-ui)
  (setq google-translate-show-phonetic t)

  (setq google-translate-default-source-language "en"
        google-translate-default-target-language "ru")

  (setq google-translate-translation-directions-alist '(("en" . "ru") ("ru" . "en")))
  ;; auto-toggle input method
  (setq google-translate-input-method-auto-toggling t
        google-translate-preferable-input-methods-alist '((nil . ("en"))
                                                          (russian-computer . ("ru")))))
#+end_src
** tab-bar-mode
New in Emacs 27.
#+begin_src emacs-lisp
(use-package tab-bar
  :general
  ('motion
   "M-h"  #'tab-bar-switch-to-prev-tab
   "M-l"  #'tab-bar-switch-to-next-tab)
  :config
  (general-def 'normal
    "M-h"  #'tab-bar-switch-to-prev-tab
    "M-l"  #'tab-bar-switch-to-next-tab)
  (general-def '(normal visual) 'org-mode-map
    "M-h" nil
    "M-l" nil)
  (general-def '(normal visual) 'evil-org-mode-map
    "M-h" nil
    "M-l" nil)
  (general-def 'org-mode-map
    "M-h" nil
    "M-l" nil)

  (setq tab-bar-select-tab-modifiers '(meta))
  (setq tab-bar-tab-hints t)

  ;; Show tab bar only if there are >1 tab
  (setq tab-bar-show nil)
  ;; Do not show buttons
  (setq tab-bar-close-button-show nil
        tab-bar-new-button-show nil)
  ;; (tab-bar-mode)
)
#+end_src
** Highlight current line
Highlight current line.
#+begin_src emacs-lisp
(global-hl-line-mode)

;; The following trick with buffer-local `global-hl-line-mode` allows
;; disabling hl-line-mode per-buffer
(make-variable-buffer-local 'global-hl-line-mode)
(defun rasen/disable-hl-line-mode ()
  (interactive)
  (setq global-hl-line-mode nil))
#+end_src
** Scrolling
=scroll-margin= is a number of lines of margin at the top and bottom of a window. Scroll the window whenever point gets within this many lines of the top or bottom of the window. (=scroll-conservatively= should be greater than 100 to never recenter point. Value 1 helps, but eventually recenters cursor if you scroll too fast.)
#+begin_src emacs-lisp
(setq scroll-margin 3
      scroll-conservatively 101)
#+end_src
** visual-fill-column
Center all text in the buffer in some modes. (That's a nice distraction-free setup.)
#+begin_src emacs-lisp
(use-package visual-fill-column
  :commands (visual-fill-column-mode)
  :hook
  (markdown-mode . rasen/activate-visual-fill-column)
  (org-mode . rasen/activate-visual-fill-column)
  :init
  (defun rasen/activate-visual-fill-column ()
    (interactive)
    (setq-local fill-column 111)
    (visual-line-mode t)
    (visual-fill-column-mode t))
  :config
  (setq-default visual-fill-column-center-text t
                visual-fill-column-fringes-outside-margins nil))
#+end_src
** Misc
Use single-key =y/n= instead of a more verbose =yes/no=.
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src
* Environment
** EXWM
Emacs is my Window Manager, thanks to [[https://github.com/ch11ng/exwm][EXWM]].

NixOS has an EXWM module, but my feeling is that it's too limiting. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.xserver.windowManager.session = lib.singleton {
    name = "exwm";
    start = ''
      xhost +SI:localuser:$USER
      exec emacs -f server-start
    '';
      # exec ${pkgs.my-emacs}/bin/emacsclient -a "" -c
  };
  services.xserver.displayManager.lightdm.enable = true;
  services.xserver.displayManager.defaultSession = "none+exwm";
}
#+end_src

Without a window compositor, I have experienced window tearing (especially in Firefox)—with picom everything runs smoothly. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  services.picom.enable = true;
}
#+end_src

Initialize EXWM configuration (emacs-lisp)
#+begin_src emacs-lisp
(use-package exwm
  :init
  ;; these must be set before exwm is loaded
  (setq mouse-autoselect-window t
        focus-follows-mouse t)
  :config
  ;; the next two make all buffers available on all workspaces
  (setq exwm-workspace-show-all-buffers t)
  (setq exwm-layout-show-all-buffers t)

  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))

  (with-eval-after-load 'evil
    (evil-set-initial-state 'exwm-mode 'motion))

  ;; do not forward anything besides keys defined with
  ;; `exwm-input-set-key' and `exwm-mode-map'
  (setq exwm-input-prefix-keys '())

  ;; Enable EXWM after all configs are loaded
  (add-hook 'emacs-startup-hook #'exwm-enable))
#+end_src

Add a couple of helpers functions. (emacs-lisp)
#+begin_src emacs-lisp
(defun rasen/autostart (cmd)
  "Start CMD unless already running."
  (let ((buf-name (concat "*" cmd "*")))
    (unless (process-live-p (get-buffer-process buf-name))
      (start-process-shell-command cmd buf-name cmd))))

(defun rasen/start-command (command &optional buffer)
  "Start shell COMMAND in the background. If BUFFER is provided, log process output to that buffer."
  (start-process-shell-command command buffer command))

(defun rasen/switch-start (buffer cmd)
  "Switch to buffer with name BUFFER or start one with CMD."
  (if-let (b (get-buffer buffer))
      (switch-to-buffer b)
    (rasen/start-command cmd)))

(defun rasen/exwm-input-set-key (key command)
  "Similar to `exwm-input-set-key', but always refreshes prefix
keys. This allows defining keys from any place in config."
  (exwm-input-set-key key command)
  ;; Alternatively, try general-setq (which calls customize handler)
  (exwm-input--update-global-prefix-keys))
#+end_src
** Window management
Common key bindings. (emacs-lisp)
#+begin_src emacs-lisp
(use-package evil
  :defer t
  :commands (evil-window-split
             evil-window-vsplit))

(defun rasen/exwm-next-workspace ()
  (interactive)
  ;; (let ((cur exwm-workspace-current-index)
  ;;       (max exwm-workspace-number))
  ;;   (exwm-workspace-switch (% (+ cur 1) max)))
  (other-frame 1))

(defun rasen/move-tab-other-frame ()
  (interactive)
  (tab-bar-move-tab-to-frame nil))

;; despite the fact s-SPC binds to nil, EXWM will add s-SPC to
;; global prefix key.
(exwm-input-set-key (kbd "s-SPC") nil)
(exwm-input-set-key (kbd "s-x") #'counsel-M-x)

(exwm-input-set-key (kbd "s-R") #'exwm-reset)
(exwm-input-set-key (kbd "s-Q") #'save-buffers-kill-terminal)
(exwm-input-set-key (kbd "s-r") (lambda (command)
                                  (interactive (list (read-shell-command "Run: ")))
                                  (rasen/start-command command)))
(exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
(exwm-input-set-key (kbd "s-b") #'counsel-switch-buffer)
(exwm-input-set-key (kbd "s-q") #'kill-this-buffer)

(exwm-input-set-key (kbd "s-\\") #'exwm-input-toggle-keyboard)
(exwm-input-set-key (kbd "<s-escape>") #'rasen/switch-to-previous-buffer)
(exwm-input-set-key (kbd "<s-tab>") #'counsel-switch-buffer)

;; window management
(exwm-input-set-key (kbd "s--") #'delete-other-windows)
(exwm-input-set-key (kbd "s-0") #'delete-window)
(exwm-input-set-key (kbd "s-h") #'windmove-left)
(exwm-input-set-key (kbd "s-k") #'windmove-down)
(exwm-input-set-key (kbd "s-j") #'windmove-up)
(exwm-input-set-key (kbd "s-l") #'windmove-right)
(exwm-input-set-key (kbd "s-s") #'evil-window-split)
(exwm-input-set-key (kbd "s-v") #'evil-window-vsplit)

(exwm-input-set-key (kbd "s-.") #'rasen/exwm-next-workspace)
(exwm-input-set-key (kbd "s->") #'rasen/move-tab-other-frame) ;; s-S-.

(general-def
  :prefix-command 'rasen/tab-map
  "t" #'tab-bar-mode
  "1" #'tab-bar-select-tab
  "2" #'tab-bar-select-tab
  "3" #'tab-bar-select-tab
  "4" #'tab-bar-select-tab
  "5" #'tab-bar-select-tab
  "6" #'tab-bar-select-tab
  "7" #'tab-bar-select-tab
  "8" #'tab-bar-select-tab
  "9" #'tab-bar-select-tab
  "n" #'tab-bar-new-tab
  "h" #'tab-bar-switch-to-prev-tab
  "l" #'tab-bar-switch-to-next-tab
  ">" #'tab-bar-move-tab-to-frame
  "k" #'tab-bar-close-tab)
(s-leader-def "t" #'rasen/tab-map)
(exwm-input-set-key (kbd "s-t") #'rasen/tab-map)

(exwm-input-set-key (kbd "s-1") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-2") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-3") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-4") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-5") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-6") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-7") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-8") #'tab-bar-select-tab)
(exwm-input-set-key (kbd "s-9") #'tab-bar-select-tab)

(exwm-input-set-key (kbd "<s-f1>") (lookup-key (current-global-map) (kbd "<f1>")))

(defun rasen/exwm-firefox ()
  (interactive)
  (rasen/switch-start "Firefox" "firefox"))

(defun rasen/exwm-telegram ()
  (interactive)
  (rasen/switch-start "TelegramDesktop" "telegram-desktop"))

(defun rasen/exwm-google-play-music ()
  (interactive)
  (rasen/switch-start "Google Play Music Desktop Player" "google-play-music-desktop-player"))

(defun rasen/terminal ()
  (interactive)
  (rasen/start-command "urxvt"))

;; From https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/
(defun rasen/switch-to-previous-buffer ()
  "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer))))

(exwm-input-set-key (kbd "s-!") #'rasen/exwm-firefox)           ;; s-S-1
(exwm-input-set-key (kbd "s-$") #'rasen/exwm-telegram)          ;; s-S-4
(exwm-input-set-key (kbd "s-&") #'rasen/exwm-google-play-music) ;; s-S-7
(exwm-input-set-key (kbd "s-(") #'notmuch)                      ;; s-S-9
(exwm-input-set-key (kbd "<s-return>") #'vterm)
(exwm-input-set-key (kbd "<s-S-return>") #'rasen/terminal)

(exwm-input-set-key (kbd "s-z") #'exwm-layout-toggle-mode-line)
(exwm-input-set-key (kbd "s-f") #'exwm-layout-toggle-fullscreen)
(exwm-input-set-key (kbd "s-C-SPC") #'exwm-floating-toggle-floating)

(general-def 'exwm-mode-map
  "C-c" nil ;; disable default bindings

  "<f1> v" #'counsel-describe-variable)

;; Without the next line, EXWM won't intercept necessary prefix keys
;; (if you rebind them after EXWM has started)
(exwm-input--update-global-prefix-keys)
#+end_src
** Window layout
Rules to automatically layout windows when they appear.
#+begin_src emacs-lisp
(setq display-buffer-alist
      '(("\\*\\(Help\\|Error\\)\\*" .
         (display-buffer-in-side-window
          (side . right)
          (slot . 1)
          (window-width . 80)
          (no-other-window . t)))
        ("\\*\\(Calendar\\)\\*" .
         (display-buffer-in-side-window
          (side . bottom)
          (slot . -1)
          ;; (window-width . 80)
          (no-other-window . t)))
        ("\\*org-roam\\*" .
         (display-buffer-in-side-window
          (side . right)
          (slot . -1)
          (window-width . 80)
          (no-other-window . t)))))
#+end_src
** Screen locking
I use ~xss-lock~ + ~slock~ for screen locking. Actual handling is coded in Emacs.
*** Slock
[[http://tools.suckless.org/slock/][Slock]] is a simple X display locker and does not crash as xscreensaver does.

Slock tries to disable OOM killer (so the locker is not killed when memory is low) and this requires a suid flag for executable. Otherwise, you get the following message:
#+begin_src fundamental :tangle no
slock: unable to disable OOM killer. Make sure to suid or sgid slock.
#+end_src

#+name: nixos-section
#+begin_src nix
{
  programs.slock.enable = true;
}
#+end_src
*** xss-lock
[[https://bitbucket.org/raymonad/xss-lock][xss-lock]] is a small utility to plug a screen locker into screen saver extension for X. This automatically activates selected screensaver after a period of user inactivity, or when system goes to sleep.

#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    pkgs.xss-lock
  ];
}
#+end_src
*** EXWM integration
Autostart ~xss-lock~ (emacs-lisp).
#+begin_src emacs-lisp
(rasen/autostart "xss-lock -n \"xset dpms force off\" slock")
#+end_src

Bind ~s-M-l~ to lock screen immediately.
#+begin_src emacs-lisp
(defun rasen/blank-screen ()
  "Blank screen after 1 second. The delay is introduced so the user
could get their hands away from the keyboard. Otherwise, the screen
would lit again immediately."
  (interactive)
  (run-at-time "1 sec" nil
               (lambda ()
                 (rasen/start-command "xset dpms force off"))))

(defun rasen/lock-screen ()
  "Lock and blank screen."
  (interactive)
  (rasen/start-command "slock")
  (rasen/blank-screen))

(rasen/exwm-input-set-key (kbd "s-M-l") #'rasen/lock-screen)
#+end_src
** System tray
Use built-in EXWM system tray (emacs-lisp)
#+begin_src emacs-lisp
(use-package exwm-systemtray
  :after exwm
  :config
  (exwm-systemtray-enable))
#+end_src
** Screenshots
I use [[https://github.com/Roger/escrotum][Escrotum]] for screenshots.

Install it. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.escrotum ];
}
#+end_src

Bind it to Print Screen button. (emacs-lisp)
#+begin_src emacs-lisp
(defun rasen/screenshot ()
  (interactive)
  ;; -sC — choose selection + save to clipboard
  (rasen/start-command "escrotum -sC"))

(rasen/exwm-input-set-key (kbd "<print>") #'rasen/screenshot)
#+end_src
** Misc
I definitely use X server:
#+name: nixos-section
#+begin_src nix
{
  services.xserver.enable = true;
}
#+end_src

Use English as my only supported locale:
#+name: nixos-section
#+begin_src nix
{
  i18n.supportedLocales = [ "en_US.UTF-8/UTF-8" ];
}
#+end_src

Setup timezone:
#+name: nixos-section
#+begin_src nix
{
  time.timeZone = "Europe/Kiev";
}
#+end_src
* Input
** Keyboard
*** Workman
I use [[https://workmanlayout.org/][Workman Layout]].
It's a nice non-qwerty layout that de-prioritizes two middle /columns,/ so your hands don't rotate too often.

It looks like this:
#+DOWNLOADED: https://nic-west.com/images/workman.png @ 2020-06-13 02:39:31
[[file:images/20200612233931-workman.png]]

Even though I am a heavy user of Vim-like keybindings, I /didn't/ remap any keys to bring h/j/k/l to the home row—yes, they all are scattered around and I consider that a feature. (You shouldn't be using h/j/k/l anyway.)

Though, there is one remapping that I actually do.
If you look at the picture, you'll notice that j—which usually means “down”—is above k on keyboard.
I could get my mind used to it, so I remap j↔k functions in all applications I use (Emacs, Vim, Firefox, Zathura).

*** Keyboard layout
Besides Workman, I use Ukrainian layout. I also use Russian symbols, but they are on the third level (~<<nixos-section>>~).
#+name: nixos-section
#+begin_src nix
{
  services.xserver.layout = "us,ua";
  services.xserver.xkbVariant = "workman,";

  # Use same config for linux console
  console.useXkbConfig = true;
}
#+end_src

Same setting but for Home Manager (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  home.keyboard = {
    layout = "us,ua";
    variant = "workman,";
  };
}
#+end_src

Map left Caps Lock to Ctrl, and left Ctrl to switch between layout. (Shift-Ctrl triggers Caps Lock function.)
I never use Caps Lock–the feature, so it's nice to have Caps LED indicate alternate layouts.

~<<nixos-section>>~:
#+name: nixos-section
#+begin_src nix
{
  services.xserver.xkbOptions = "grp:lctrl_toggle,grp_led:caps,ctrl:nocaps";
  # services.xserver.xkbOptions = "grp:caps_toggle,grp_led:caps";
}
#+end_src

*** Xkeymap
I have a slightly customized Workman+Ukrainian layout at [[./Xkeymap]] (more keys on 3rd level). It's quite big and isn't particularly fun to explain, so I keep it off my main config.

Activate it on session start (~<<home-manager-section>>~).
#+name: home-manager-section
#+begin_src nix
{
  xsession.initExtra = ''
    xkbcomp ${./Xkeymap} $DISPLAY
  '';
}
#+end_src

One caveat is that it's dropped when I activate (update) new system version, or when unplug keyboard and plug it again.

Add a small Emacs function to re-apply this configuration (emacs-lisp).
#+begin_src emacs-lisp
(defun rasen/set-xkb-layout ()
  (interactive)
  (rasen/autostart "xkbcomp ~/dotfiles/Xkeymap $DISPLAY"))

(rasen/set-xkb-layout)
#+end_src

Install xkbcomp to execute these commands. (~<<home-manager-seciton>>~)
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.xorg.xkbcomp ];
}
#+end_src

*** Emacs quail
Emacs has built-in capability to change keyboard layout (for insert state only), which is triggered by =C-\=. In order to work properly, Emacs needs to know my keyboard layout.
#+begin_src emacs-lisp
(use-package quail
  :ensure nil ; built-in
  :config
  (add-to-list 'quail-keyboard-layout-alist
               '("workman" . "\
                              \
  1!2@3#4$5%6^7&8*9(0)-_=+`~  \
  qQdDrRwWbBjJfFuUpP;:[{]}\\|  \
  aAsShHtTgGyYnNeEoOiI'\"      \
  zZxXmMcCvVkKlL,<.>/?        \
                              "))
  (quail-set-keyboard-layout "workman"))
#+end_src
** Mouse
I use [[https://www.razer.com/eu-en/Gaming-Mice/Razer-Naga-Chroma/p/RZ01-01610100-R3G1][Razer Naga Chroma]] with 12-button thumb cluster. I use these buttons are used to switch browser tabs, close/open them, go back and forth in history so that sometimes I can browse web only using one hand.

*** Python listener
I have a small Python script at [[./naga]] to connect to mouse as input device and report button pressed to Emacs.

The script is pretty simple ([[./naga/naga/__init__.py]]).
#+begin_src python :tangle naga/naga/__init__.py
#!/usr/bin/env python3
import evdev
import subprocess


def value_to_string(val):
    if val == evdev.events.KeyEvent.key_up:
        return "up"
    if val == evdev.events.KeyEvent.key_down:
        return "down"
    if val == evdev.events.KeyEvent.key_hold:
        return "hold"
    return None


def main():
    device = evdev.InputDevice(
        "/dev/input/by-id/usb-Razer_Razer_Naga_Chroma-if02-event-kbd"
    )
    print(device)

    device.grab()

    for event in device.read_loop():
        if event.type == evdev.ecodes.EV_KEY:
            subprocess.call(
                [
                    "emacsclient",
                    "--eval",
                    '(rasen/razer {} "{}")'.format(
                        event.code - 1, value_to_string(event.value)
                    ),
                ]
            )
#+end_src

~setup.py~ to make it installable ([[./naga/setup.py]]).
#+begin_src python :tangle naga/setup.py
#!/usr/bin/env python
from setuptools import setup

setup(
    name='naga',
    version='1.0',
    url='https://github.com/rasenduby/dotfiles',
    packages=['naga'],
    entry_points={
        'console_scripts': [
            'naga=naga:main',
        ],
    },
    license='MIT',
    install_requires=[
        'evdev',
    ],
)
#+end_src

And ~default.nix~ to make it installable with Nix ([[./naga/default.nix]]).
#+begin_src nix :tangle naga/default.nix
{ lib, python3Packages }:
python3Packages.buildPythonApplication {
  name = "naga-1.0";

  src = lib.cleanSource ./.;

  propagatedBuildInputs = [
    python3Packages.evdev
  ];
}
#+end_src

Expose naga as Flake packages (~<<flake-packages>>~).
#+name: flake-packages
#+begin_src nix
{
  naga = pkgs.callPackage ./naga { };
}
#+end_src

Finally install it (~<<home-manager-section>>~).
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.naga ];
}
#+end_src

And I believe I need to add my user to ~input~ group to fix permissions (~<<nixos-section>>~).
#+name: nixos-section
#+begin_src nix
{
  users.users.rasen.extraGroups = [ "input" ];
}
#+end_src

Activate it on EXWM start (emacs-lisp).
#+begin_src emacs-lisp
(defun rasen/naga ()
  (interactive)
  (rasen/autostart "naga"))

(rasen/naga)
#+end_src
**** TODO Start naga on plugdev
*** Emacs handler
Emacs determines what to do with each keypress.

#+begin_src emacs-lisp
(defun rasen/exwm-send-keys (keys)
  (dolist (key (append keys nil))
    (exwm-input--fake-key key)))

(defun rasen/razer (code value)
  (with-current-buffer (window-buffer (selected-window))
    ;; (message "(razer %s %s) class-name=%s" code value exwm-class-name)
    (when (string= value "down")
      (cond ((= code 11) (rasen/switch-to-previous-buffer))
            ((or (string= exwm-class-name "Firefox") (string= exwm-class-name "Google-chrome"))
             (cond
              ((= code 1) (rasen/exwm-send-keys (kbd "<M-left>"))) ;; back (history)
              ((= code 2) (rasen/exwm-send-keys (kbd "<C-prior>"))) ;; prev tab
              ((= code 3) (rasen/exwm-send-keys (kbd "<C-next>"))) ;; next tab
              ((= code 4) (rasen/exwm-send-keys (kbd "<M-right>")));; next (history)
              ((= code 5) (rasen/exwm-send-keys (kbd "C-S-t"))) ;; restore last closed tab
              ((= code 6) (rasen/exwm-send-keys (kbd "C-w"))) ;; close tab
              ((= code 12) (rasen/exwm-send-keys (kbd "<C-tab>"))) ;; switch to previous tab
              ))
            ((string= exwm-class-name "TelegramDesktop")
             (cond
              ((= code 1) (rasen/exwm-send-keys (kbd "<escape>"))) ;; deselect conversation
              ((= code 2) (rasen/exwm-send-keys (kbd "<C-S-tab>"))) ;; prev conversation
              ((= code 3) (rasen/exwm-send-keys (kbd "<C-tab>"))) ;; next conversation
              ))
            (t (message "razer-unhandled %s" code))))))
#+end_src
* Network
** NetworkManager
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  networking = {
    hostName = name;

    networkmanager = {
      enable = true;
      wifi.powersave = false;
    };

    # disable wpa_supplicant
    wireless.enable = false;
  };

  users.extraUsers.rasen.extraGroups = [ "networkmanager" ];
}
#+end_src

Install network manager applet for user. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.networkmanagerapplet ];
}
#+end_src

Auto-start ~nm-applet~ (emacs-lisp)
#+begin_src emacs-lisp
(rasen/autostart "nm-applet")
#+end_src
** VPN
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.openvpn.servers.nano-vpn = {
    config = ''
      config /root/openvpn/nano-vpn.ovpn
    '';
  };
}
#+end_src
** SSH
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.openssh = {
    enable = true;
    passwordAuthentication = false;
  };
}
#+end_src
*** Mosh
[[https://mosh.mit.edu/][Mosh (mobile shell)]] is a cool addition to ssh.
#+name: nixos-section
#+begin_src nix
{
  programs.mosh.enable = true;
}
#+end_src
** dnsmasq
Use [[http://www.thekelleys.org.uk/dnsmasq/doc.html][dnsmasq]] as a DNS cache.

(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.dnsmasq = {
    enable = true;

    # These are used in addition to resolv.conf
    servers = [
      "8.8.8.8"
      "8.8.4.4"
    ];

    extraConfig = ''
      listen-address=127.0.0.1
      cache-size=1000

      no-negcache
    '';
  };
}
#+end_src
** Firewall
Enable firewall. This blocks all ports for ingress traffic and pings.

(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  networking.firewall = {
    enable = true;
    allowPing = false;

    connectionTrackingModules = [];
    autoLoadConntrackHelpers = false;
  };
}
#+end_src
* Services
** Locate
Update [[https://linux.die.net/man/1/locate][locate]] database daily.
#+name: nixos-section
#+begin_src nix
{
  services.locate = {
    enable = true;
    localuser = "rasen";
  };
}
#+end_src
** Gitolite
#+name: nixos-section
#+begin_src nix
{
  services.gitolite = {
    enable = true;
    user = "git";
    adminPubkey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHH15uiQw3jBbrdlcRb8wOr8KVltuwbHP/JOFAzXFO1l/4QxnKs6Nno939ugULM7Lu0Vx5g6FreuCOa2NMWk5rcjIwOzjrZnHZ7aoAVnE7H9scuz8NGnrWdc1Oq0hmcDxdZrdKdB6CPG/diGWNZy77nLvz5JcX1kPLZENPeApCERwR5SvLecA4Es5JORHz9ssEcf8I7VFpAebfQYDu+VZZvEu03P2+5SXv8+5zjiuxM7qxzqRmv0U8eftii9xgVNC7FaoRBhhM7yKkpbnqX7IeSU3WeVcw4+d1d8b9wD/sFOyGc1xAcvafLaGdgeCQGU729DupRRJokpw6bBRQGH29 rasen@omicron";
  };
}
#+end_src
** Syncthing
I use Syncthing to sync my org-mode files to my phone.

#+name: nixos-section
#+begin_src nix
{
  services.syncthing = {
    enable = true;
    user = "rasen";
    dataDir = "/home/rasen/.config/syncthing";
    configDir = "/home/rasen/.config/syncthing";
    openDefaultPorts = true;
  };
}
#+end_src
** Docker
** Backup
I use borg for backups.

#+name: machine-omicron
#+begin_src nix
(let
  commonOptions = {
    repo = "borg@10.13.0.3:.";
    encryption.mode = "keyfile-blake2";
    encryption.passCommand = "cat /root/secrets/borg";
    compression = "auto,lzma,9";
    doInit = false;
    environment = { BORG_RSH = "ssh -i /root/.ssh/borg"; };
    # UTC timestamp
    dateFormat = "-u +%Y-%m-%dT%H:%M:%S";
  };
in {
  services.borgbackup.jobs."all" = commonOptions // {
    archiveBaseName = "${config.networking.hostName}";
    paths = [
      "/var/lib/gitolite/"
      "/home/rasen/backup/"
      "/home/rasen/.ssh/"
      "/home/rasen/.gnupg/"
      "/home/rasen/.password-store/"
      "/home/rasen/dotfiles/"
      "/home/rasen/org/"

      # Mail
      "/home/rasen/Mail/"
      "/home/rasen/.mbsync/"
    ];
    exclude = [
      # Scanning notmuch takes too much time and doesn't make much
      # sense as it is easily replicable
      "/home/rasen/Mail/.notmuch"
    ];
  };

  # Start backup on boot if missed one while laptop was off
  systemd.timers.borgbackup-job-all.timerConfig = {
    Persistent = true;
  };

  # Require VPN connection for repo to be reachable
  systemd.services.borgbackup-job-all = {
    requires = ["openvpn-nano-vpn.service"];
  };
})
#+end_src
** direnv + lorri
direnv allows having per-directory environment configuration. You can think of automatic virtualenv, but it's more general and supports unloading.

(~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.direnv.enable = true;
  services.lorri.enable = true;
}
#+end_src

Enable Emacs integration. (emacs-lisp)
#+begin_src emacs-lisp
(use-package direnv
  :config
  (direnv-mode))
#+end_src
* Hardware
** Autorandr
Configure EXWM to use autorandr. (emacs-lisp)
#+begin_src emacs-lisp
(use-package exwm-randr
  :after exwm
  :config
  (setq exwm-workspace-number 2)
  (setq exwm-randr-workspace-output-plist '(0 "eDP-1"
                                              1 "DP-1"
                                              1 "DP-3"))

  (add-hook 'exwm-randr-screen-change-hook
            (defun rasen/autorandr ()
              (interactive)
              (rasen/start-command "autorandr -c" "*autorandr*")))

  (exwm-randr-enable))
#+end_src

(~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.autorandr = {
    enable = true;
    profiles =
      let
        omicron = "00ffffffffffff004d104a14000000001e190104a51d11780ede50a3544c99260f505400000001010101010101010101010101010101cd9180a0c00834703020350026a510000018a47480a0c00834703020350026a510000018000000fe0052584e3439814c513133335a31000000000002410328001200000b010a202000cc";
        work = "00ffffffffffff004d108d1400000000051c0104a52213780ea0f9a95335bd240c5157000000010101010101010101010101010101014dd000a0f0703e803020350058c210000018000000000000000000000000000000000000000000fe00464e564452804c513135364431000000000002410328011200000b010a202000ee";
        home-monitor = "00ffffffffffff0010acc0a042524530031c010380351e78eae245a8554da3260b5054a54b00714f8180a9c0a940d1c0e10001010101a36600a0f0701f80302035000f282100001a000000ff004438565846383148304552420a000000fc0044454c4c205032343135510a20000000fd001d4c1e8c1e000a202020202020018802032ef15390050402071601141f1213272021220306111523091f07830100006d030c001000003c200060030201023a801871382d40582c25000f282100001e011d8018711c1620582c25000f282100009e04740030f2705a80b0588a000f282100001e565e00a0a0a02950302035000f282100001a0000000000000000008a";
        work-monitor = "00ffffffffffff0010acc2d0545741312c1b010380351e78eaad75a9544d9d260f5054a54b008100b300d100714fa9408180d1c00101565e00a0a0a02950302035000e282100001a000000ff004d59334e44374234314157540a000000fc0044454c4c205032343138440a20000000fd0031561d711c000a202020202020010302031bb15090050403020716010611121513141f2065030c001000023a801871382d40582c45000e282100001e011d8018711c1620582c25000e282100009ebf1600a08038134030203a000e282100001a7e3900a080381f4030203a000e282100001a00000000000000000000000000000000000000000000000000000000d8";
      in {
      "omicron" = {
        fingerprint = {
          eDP-1 = omicron;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "0x0";
            mode = "3200x1800";
            rate = "60.00";
          };
        };
      };
      "omicron-home" = {
        fingerprint = {
          eDP-1 = omicron;
          DP-1 = home-monitor;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "320x2160";
            mode = "3200x1800";
            rate = "60.00";
          };
          DP-1 = {
            enable = true;
            position = "0x0";
            mode = "3840x2160";
            rate = "60.00";
          };
        };
      };

      "work" = {
        fingerprint = {
          eDP-1 = work;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "0x0";
            mode = "3840x2160";
            rate = "60.00";
            dpi = 284;
          };
        };
      };
      "work-home" = {
        fingerprint = {
          eDP-1 = work;
          DP-3 = home-monitor;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "0x2160";
            mode = "3840x2160";
            rate = "60.00";
            dpi = 284;
          };
          DP-3 = {
            enable = true;
            position = "0x0";
            mode = "3840x2160";
            rate = "29.98";
            dpi = 183;
          };
        };
      };
      "work-home-usbc" = {
        fingerprint = {
          eDP-1 = work;
          DP-1 = home-monitor;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "0x2160";
            mode = "3840x2160";
            rate = "60.00";
            dpi = 284;
          };
          DP-1 = {
            enable = true;
            position = "0x0";
            mode = "3840x2160";
            rate = "29.98";
            dpi = 183;
          };
        };
      };
      "work-work" = {
        fingerprint = {
          eDP-1 = work;
          DP-3 = work-monitor;
        };
        config = {
          eDP-1 = {
            enable = true;
            primary = true;
            position = "0x1440";
            mode = "3840x2160";
            rate = "60.00";
            dpi = 284;
          };
          DP-3 = {
            enable = true;
            position = "640x0";
            mode = "2560x1440";
            rate = "59.95";
            dpi = 124;
          };
        };
      };
    };
  };
}
#+end_src
** Screen brightness
=xbacklight= stopped working recently. =acpilight= is a drop-in replacement.
#+name: nixos-section
#+begin_src nix
{
  hardware.acpilight.enable = true;
  environment.systemPackages = [ pkgs.acpilight ];
  users.extraUsers.rasen.extraGroups = [ "video" ];
}
#+end_src

For Home Manager–managed hosts.
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.acpilight ];
}
#+end_src

Bind it to keys (emacs-lisp).
#+begin_src emacs-lisp
(rasen/exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                          (lambda () (interactive) (rasen/start-command "xbacklight -inc 10")))
(rasen/exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                          (lambda () (interactive) (rasen/start-command "xbacklight -dec 10")))
#+end_src
** Redshift
Redshift adjusts the color temperature of the screen according to the position of the sun.

Blue light blocks [[https://en.wikipedia.org/wiki/Melatonin][melatonin]] (sleep harmone) secretion, so you feel less sleepy when you stare at computer screen.
Redshift blocks some blue light (making screen more red), which should improve melatonin secretion and restore sleepiness (which is a good thing).

#+name: nixos-section
#+begin_src nix
{
  services.redshift = {
    enable = true;
  };
  location.provider = "geoclue2";
}
#+end_src
** PulseAudio
Use pulseaudio (multiple sound sinks, skype calls).

Also, Pulseaudio is a requirement for Firefox Quantum. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  hardware.pulseaudio = {
    enable = true;
    support32Bit = true;
  };
}
#+end_src

=pavucontrol= is PulseAudio Volume Control—a nice utility for controlling pulseaudio settings. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.pavucontrol ];
}
#+end_src

Start pulseaudio on WM start. (emacs-lisp)
#+begin_src emacs-lisp
(rasen/autostart "start-pulseaudio-x11")
#+end_src

Bind volume control commands. (emacs-lisp)
#+begin_src emacs-lisp
(rasen/exwm-input-set-key (kbd "<XF86AudioMute>")
                          (lambda () (interactive) (rasen/start-command "amixer set Master toggle")))
(rasen/exwm-input-set-key (kbd "<XF86AudioRaiseVolume>")
                          (lambda () (interactive) (rasen/start-command "amixer set Master 2%+")))
(rasen/exwm-input-set-key (kbd "<XF86AudioLowerVolume>")
                          (lambda () (interactive) (rasen/start-command "amixer set Master 2%-")))
#+end_src
** Bluetooth
I have a bluetooth headset, so this enables bluetooth audio in NixOS.

(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
  {
    hardware.bluetooth.enable = true;
    hardware.pulseaudio = {
      enable = true;

      # NixOS allows either a lightweight build (default) or full build
      # of PulseAudio to be installed.  Only the full build has
      # Bluetooth support, so it must be selected here.
      package = pkgs.pulseaudioFull;
    };
  }
#+end_src
** ADB
I need to access my Android device. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.udev.packages = [ pkgs.android-udev-rules ];
  programs.adb.enable = true;
  users.users.rasen.extraGroups = ["adbusers"];
}
#+end_src
** fwupd
fwupd is a service that allows applications to update firmware. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  services.fwupd.enable = true;
}
#+end_src

Execute the following command to update firmware.
#+begin_src sh :tangle no
fwupdmgr get-updates
#+end_src
* Browsers
Firefox is default, Chrome for backup.
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    pkgs.firefox
    pkgs.google-chrome
  ];
}
#+end_src
** Tridactyl
Tridactyl is a Firefox plugin that provides Vim-like bindings.

Here is my config. (~<<tridactylrc>>~)
#+name: tridactylrc
#+begin_src fundamental :tangle no
" drop all existing configuration
sanitize tridactyllocal tridactylsync

bind J scrollline -10
bind K scrollline 10
bind j scrollline -2
bind k scrollline 2
#+end_src

Link tridactyl config to the place the tridactyl can find it. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  xdg.configFile."tridactyl/tridactylrc".text = ''
    <<tridactylrc>>
  '';
}
#+end_src
** Edit text in browser
I use [[https://github.com/GhostText/GhostText][GhostText]] firefox extension.

~atomic-chrome~ Emacs extension is compatible with it. (emacs-lisp)
#+begin_src emacs-lisp
(use-package atomic-chrome
  :config
  (setq atomic-chrome-default-major-mode 'markdown-mode)
  (setq atomic-chrome-buffer-open-style 'frame)
  (atomic-chrome-start-server))
#+end_src
** Online banking
My bank uses a two-part websigner. The first part is a browser extension (does not require additional setup) and the second part is a native host application companion (it is installed here).

Pack native messaging host. (~<<flake-packages>>~)
#+name: flake-packages
#+begin_src nix
(let
  websigner =
    { stdenv
    , fetchurl
    , autoPatchelfHook
    , gtk2
    , glib
    , pcsclite
    }:
    stdenv.mkDerivation {
      pname = "procreditbank-websigner";
      version = "2020-01-20";

      src = fetchurl {
        url = "https://ibank.procreditbank.com.ua/websigner-linux.bin";
        sha256 = "1bm88jg7nhgrmc0q5hv35hgv4nc0d15ihl0acrhf6x5f7wv4pszv";
      };

      nativeBuildInputs = [ autoPatchelfHook ];

      buildInputs = [ gtk2 glib pcsclite ];

      unpackCmd = ''
        sh $src --extract
      '';

      dontConfigure = true;

      dontBuild = true;

      installPhase = ''
        mkdir -p $out/bin
        mkdir -p $out/lib/websigner/hosts/firefox
        mkdir -p $out/lib/websigner/hosts/chromium

        install -m 555 x86_64-linux/npwebsigner.so $out/lib/websigner
        install -m 777 x86_64-linux/nmwebsigner $out/lib/websigner

        sed "s|PLUGIN_PATH|$out/lib/websigner/nmwebsigner|" com.bifit.websigner-mozilla.json > $out/lib/websigner/hosts/firefox/com.bifit.websigner.json
        sed "s|PLUGIN_PATH|$out/lib/websigner/nmwebsigner|" com.bifit.websigner-chrome.json > $out/lib/websigner/hosts/chromium/com.bifit.websigner.json

        mkdir -p $out/lib/mozilla/native-messaging-hosts
        ln -s $out/lib/websigner/hosts/firefox/*.json $out/lib/mozilla/native-messaging-hosts
      '';
    };
in {
  procreditbank-websigner = pkgs.callPackage websigner { };
})
#+end_src

Override Firefox to use websigner. (~<<flake-overlays>>~)
#+name: flake-overlays
#+begin_src nix
(final: prev: {
  firefox = prev.firefox.override {
    extraNativeMessagingHosts = [ final.procreditbank-websigner ];
  };
})
#+end_src
* Evil-mode
** General
#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil)
  :custom
  (evil-undo-system 'undo-redo)
  :config
  <<evil-config>>
  (evil-mode 1))
#+end_src

Hard way: prohibit usage of keybindings I have more efficient bindings for.
#+name: evil-config
#+begin_src emacs-lisp
(defmacro rasen/hard-way (key)
  `(lambda () (interactive) (error "Don't use this key! Use %s instead" ,key)))
#+end_src

Swap =.= and =;=.
#+name: evil-config
#+begin_src emacs-lisp
(general-def 'normal
  ";"    #'evil-repeat
  "."    nil
  "C-;"  #'evil-repeat-pop
  "C-."  nil)

(general-def 'motion
  "."    #'evil-repeat-find-char
  ";"    nil
  "g."   #'goto-last-change
  "g;"   nil)
#+end_src

#+name: evil-config
#+begin_src emacs-lisp
(s-leader-def
  ";"  #'eval-expression)
#+end_src

Close other window.
#+name: evil-config
#+begin_src emacs-lisp
(defun rasen/quit-other ()
  (interactive)
  (other-window 1)
  (quit-window))

(s-leader-def
  "q"  #'rasen/quit-other)
#+end_src

Move to beginning/end of line with =H= and =L= respectively.
#+name: evil-config
#+begin_src emacs-lisp
(defun rasen/smart-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(general-def 'motion
  "H"  #'rasen/smart-move-beginning-of-line
  "L"  #'evil-end-of-line)
#+end_src

Save buffer with =SPC SPC=.
#+name: evil-config
#+begin_src emacs-lisp
(defun rasen/save-buffer (arg)
  "Save current buffer.  With PREFIX, save all buffers."
  (interactive "P")
  (if arg
      (save-some-buffers)
    (save-buffer)))

(s-leader-def 'normal
  "SPC" #'rasen/save-buffer)
(s-leader-def
  "s-SPC" #'save-some-buffers)
#+end_src
** Swap k and j
With workman layout, =j= is located on qwerty =y= and =k=---on qwerty =n=; thus =j= is higher than =k=, and it is not convenient to press lower key for going up. Just swap them.
#+name: evil-config
#+begin_src emacs-lisp
(general-def 'motion
  "k"    #'evil-next-visual-line
  "j"    #'evil-previous-visual-line
  "gk"   #'evil-next-line
  "gj"   #'evil-previous-line)

(general-def 'operator
  "k"    #'evil-next-line
  "j"    #'evil-previous-line
  "gk"   #'evil-next-visual-line
  "gj"   #'evil-previous-visual-line)

(general-def 'motion
  "C-h"  #'windmove-left
  "C-k"  #'windmove-down
  "C-j"  #'windmove-up
  "C-l"  #'windmove-right)

(general-swap-key nil 'motion
  "C-w j" "C-w k")
#+end_src
** evil-numbers
I use Vim's =C-a= and =C-x= (increment/decrement number at point) a lot.
=evil-numbers= provides that functionality for evil.
#+begin_src emacs-lisp
(use-package evil-numbers
  :after evil
  :general
  ('normal
   "C-a" #'evil-numbers/inc-at-pt
   "C-x" #'evil-numbers/dec-at-pt))
#+end_src

Now, remap =C-x= to =RET=. (Because =C-x= is used for decrementing numbers.)
#+name: evil-config
#+begin_src emacs-lisp
(general-def 'motion
  "RET" (lookup-key (current-global-map) (kbd "C-x")))
;; Unmap it from magit
(general-def magit-file-mode-map
  "C-x" nil)
#+end_src
** evil-collection
evil-collection is a collection of evil bindings for different modes.
#+begin_src emacs-lisp
(require 'warnings)
(add-to-list 'warning-suppress-types '(evil-collection))

(use-package evil-collection
  :after (evil)
  :config
  (defun rasen/rotate-keys (_mode mode-keymaps &rest _rest)
    (evil-collection-translate-key 'normal mode-keymaps
      "k" "j"
      "j" "k"
      "gk" "gj"
      "gj" "gk"
      (kbd "M-j") (kbd "M-k")
      (kbd "M-k") (kbd "M-j")
      (kbd "C-j") nil ; used for window-management
      (kbd "C-k") nil ; used for window-management
      "." ";"
      ";" "."))
  (add-hook 'evil-collection-setup-hook #'rasen/rotate-keys)

  (setq evil-collection-mode-list
        '(dired
          compile
          flycheck
          help
          js2-mode
          ;; notmuch bindings aren't that cool and are less efficient than native
          ;; keymap
          ;; notmuch
          python
          racer
          restclient
          tide
          typescript-mode
          vterm
          which-key
          xref))

  (evil-collection-init))
#+end_src
** evil-surrond
#+begin_src emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode t))
#+end_src
** calc
#+name: evil-config
#+begin_src emacs-lisp
(use-package calc ; built-in
  :general
  ('motion
   "g ="  #'quick-calc
   "g +"  #'calc))
#+end_src
** Evilify compile mode
#+begin_src emacs-lisp
(use-package compile ; built-in
  :config
  (setq compilation-scroll-output t))
#+end_src

And evil commands to go to navigate errors.
#+name: evil-config
#+begin_src emacs-lisp
(leader-def 'motion
  ","  #'previous-error
  "."  #'next-error)
(general-def 'motion
  "M-,"    #'previous-error
  "M-."    #'next-error)
#+end_src
** Evilify minibuffer
Not really "evilify."
#+begin_src emacs-lisp
(general-def 'minibuffer-local-map
  ;; Finish input with C-e ("e" in Workman is qwerty's "k")
  "C-e"  #'exit-minibuffer)
#+end_src
** Evilify shell mode
Default bindings for ~RET~ prevent many of my commands from working. Remap ~RET~ to ~C-RET~.
#+begin_src emacs-lisp
(general-def 'shell-mode-map
  "RET"         nil
  "<C-return>"  #'comint-send-input)
#+end_src
** lispyville
#+begin_src emacs-lisp
(use-package lispyville
  :hook
  ((clojure-mode emacs-lisp-mode) . lispyville-mode)
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     ;; < and >
     slurp/barf-cp
     (atom-movement t)
     commentary
     ;; wrap with M-(, M-[, or M-{
     wrap
     additional
     ;; M-o open below list, M-O open above list
     additional-insert))

  ;; override drag directions
  (lispyville--define-key 'normal
    (kbd "M-j") #'lispyville-drag-backward
    (kbd "M-k") #'lispyville-drag-forward))
#+end_src
* Org-mode
** General
#+begin_src emacs-lisp
(use-package org
  :mode ("\\.org$" . org-mode)
  :general
  ("C-c l"  #'org-store-link)
  (s-leader-def
    "c"  #'org-capture
    "a"  #'org-agenda

    "o"  #'org-clock-out
    "l"  #'org-clock-in-last
    "j"  #'org-clock-goto)
  (leader-def 'normal 'org-mode-map
    "t"  #'org-todo
    "s"  #'org-schedule
    "d"  #'org-deadline
    "i"  #'org-clock-in

    "T"  #'rasen/org-do-today

    "w"  #'org-refile
    "r"  #'org-archive-subtree-default

    "n s" #'org-narrow-to-subtree)
  ('(insert normal) 'org-mode-map
   "C-c ,"  #'org-time-stamp-inactive)
  ('org-mode-map
   ;; tabs
   "M-l" nil
   "M-h" nil)
  :gfhook 'flyspell-mode
  :ensure org-plus-contrib
  :init
  <<org-init>>
  :config
  <<org-config>>
  )
#+end_src

Do not indent inside tasks
#+name: org-config
#+begin_src emacs-lisp
(setq org-adapt-indentation nil)
#+end_src

Do not indent org-babel blocks.
#+name: org-config
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
#+end_src

Do not indent tags.
#+name: org-config
#+begin_src emacs-lisp
(setq org-tags-column 0)
#+end_src

#+name: org-config
#+begin_src emacs-lisp
(setq org-ellipsis "…")
#+end_src

By default, show overview when opening org files. (This used to be default.)
#+name: org-config
#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

Make the table header float if scrolled out of view.
#+name: org-config
#+begin_src emacs-lisp
(setq org-table-header-line-p t)
#+end_src

#+name: org-config
#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)

;; allow ndash/mdash before/after emphasis markers.
;; (copy-modified from original `org-emphasis-regexp-components' definition)
(org-set-emph-re 'org-emphasis-regexp-components
                 '("-–—[:space:]('\"{" "-–—[:space:].,:!?;'\")}\\[" "[:space:]" "." 1))
#+end_src

Open pdfs in external viewer:
#+name: org-config
#+begin_src emacs-lisp
(add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s"))
#+end_src

Use =whitespace-mode= in Org (but don't show too long lines).
#+name: org-config
#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda ()
                           (setq-local whitespace-style '(face
                                                          tab-mark
                                                          empty
                                                          trailing))
                           (whitespace-mode t)))
#+end_src

My directory for org files.
#+name: org-config
#+begin_src emacs-lisp
(setq rasen/org-directory "~/org")
#+end_src

My helper to find all org files in a directory.
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/org-files-in-dir (dir)
  (f-files dir
           (lambda (file) (or (f-ext? file "org")
                              (and (f-ext? file "gpg")
                                   (f-ext? (f-no-ext file) "org"))))
           nil))
#+end_src

Package for =f-files= and =f-ext?= functions.
#+name: org-init
#+begin_src emacs-lisp
(use-package f
  :commands (f-files f-ext? f-no-ext))
#+end_src
** Drill
#+name: org-config
#+begin_src emacs-lisp
(use-package org-drill
  :commands (org-drill)
  :config
  (setq org-drill-scope (rasen/org-files-in-dir "~/org/drill"))
  (add-to-list 'org-modules 'org-drill)

  (setq org-drill-leech-failure-threshold 10
        org-drill-leech-method 'warn))
#+end_src
** Todo
Use the following states: =TODO= =NEXT= =DONE= =CANCELED= =WAIT=.
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-todo-keywords
              '((sequence "TODO(t)" "NEXT(n!)" "|" "DONE(d!)")
                (sequence "BUILD(b!)" "|")
                (sequence "|" "CANCELED(c@)")
                (sequence "WAIT(w@)" "|")))
(setq-default org-use-fast-todo-selection t)
#+end_src

When repeated task is finished, go back to =TODO= state.
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-todo-repeat-to-state "TODO")
#+end_src

Log state changes to "LOGBOOK" drawer.
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-log-into-drawer 't)
#+end_src

Save =CLOSED= timestamp when task is done.
#+name: org-config
#+begin_src emacs-lisp
(setq org-log-done t)
#+end_src

Fontify the whole line for done tasks.
#+begin_src emacs-lisp
(setq org-fontify-done-headline t)
#+end_src

Import =org-expiry= for =org-expiry-insert-created=---this inserts =CREATED= property.
#+name: org-config
#+begin_src emacs-lisp
(require 'org-expiry)
(setq org-expiry-inactive-timestamps t)
(org-expiry-insinuate)
#+end_src

Schedule task for today and mark it NEXT.
I use this a lot during daily planning.
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/org-do-today (&optional arg)
  "Schedule task for today and mark it NEXT.

If prefix is supplied, select different scheduled time."
  (interactive "P")
  (org-schedule nil (unless arg "."))
  (org-todo "NEXT"))
#+end_src
** Clocking
Remove clocks with 0 duration.
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-clock-out-remove-zero-time-clocks t)
#+end_src

Save more last clocks.
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-clock-history-length 10)
#+end_src
** Capture
I use an extension that adds page url to the title (used for page tracking). Strip it down here
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/strip-url-from-title (title)
  (message "stripping: %s" title)
  (replace-regexp-in-string
   " @ [^ ]*$"
   ""
   (replace-regexp-in-string " \\[[^]]*\\]\\[[^]]*\\]$" "" title)))
#+end_src

My capture templates.
#+name: org-config
#+begin_src emacs-lisp
(setq rasen/org-refile-file (concat rasen/org-directory "/refile-" system-name ".org"))
(setq org-capture-templates
      `(("u"
         "Task: Read this URL"
         entry
         (file rasen/org-refile-file)
         ,(concat "* TODO %(rasen/strip-url-from-title \"%:description\")\n"
                  ":PROPERTIES:\n"
                  ":CREATED:  %U\n"
                  ":END:\n"
                  "%:link\n")
         :immediate-finish t)

        ("w"
         "Capture web snippet"
         entry
         (file rasen/org-refile-file)
         ,(concat "* %(rasen/strip-url-from-title \"%:description\")\n"
                  ":PROPERTIES:\n"
                  ":CREATED:  %U\n"
                  ":SOURCE_URL: %:link\n"
                  ":END:\n"
                  "#+begin_quote\n"
                  "%i\n"
                  "#+end_quote\n"
                  "%?\n")
         :immediate-finish t)

        ("j" "Journal entry" plain
         (file+datetree+prompt "~/org/journal.org")
         ,(concat
           "TIL:\n- %?\n\n"
           ;; %U does not work here because timestamp is hijacked by
           ;; %file+datetime+prompt
           "%(format-time-string (org-time-stamp-format t t))"
           "\n"))

        ("t" "todo" entry (file rasen/org-refile-file)
         "* TODO %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n" :clock-in t :clock-resume t)

        ("T" "today" entry (file rasen/org-refile-file)
         "* NEXT %?\nSCHEDULED: %t\n:PROPERTIES:\n:CREATED:  %U\n:END:\n" :clock-in t :clock-resume t)

        ("m" "meeting" entry (file rasen/org-refile-file)
         "* %?   :Meeting:\n:PROPERTIES:\n:CREATED:  %U\n:END:\n" :clock-in t :clock-resume t)

        ("n" "note" entry (file rasen/org-refile-file)
         "* %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n")

        ("l" "link" entry (file rasen/org-refile-file)
         "* %a \n:PROPERTIES:\n:CREATED:  %U\n:END:\n"
         :immediate-finish t)))

(defun rasen/org-capture-link ()
  (interactive)
  (org-capture nil "l"))
#+end_src

Enable org-protocol.
#+name: org-config
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

=%l= in org-capture fails with multiline context, so use only the first line as a context.
#+name: org-config
#+begin_src emacs-lisp
(setq org-context-in-file-links 1)
#+end_src

*** org-capture keybindings
Instanly go into insert mode on capture.
#+name: org-config
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

#+name: org-config
#+begin_src emacs-lisp
(general-def
  :keymaps 'org-capture-mode-map
  :states 'normal
  "'"      #'org-capture-finalize)
(leader-def 'normal 'org-capture-mode-map
  "w" #'org-capture-refile)
#+end_src
** Capturing images
#+begin_src emacs-lisp
(use-package org-download
  :init
  (el-patch-feature org-download)
  :config
  (setq org-download-method 'directory)
  ;; Do not prepend heading name to the file path
  (setq-default org-download-heading-lvl nil)
  ;; "download" screenshots from clipboard
  (setq org-download-screenshot-method "xclip -selection clipboard -t image/png -o > %s")

  ;; Use timestamp-ids
  (el-patch-defun org-download-file-format-default (filename)
    "It's affected by `org-download-timestamp'."
    (concat
     (el-patch-swap
       (format-time-string org-download-timestamp)
       (rasen/tsid))
     (el-patch-add "-")
     filename)))
#+end_src
** datetree
#+begin_src emacs-lisp
;; adapted from org-capture module

(defun rasen/org-datetree-entry (arg)
  "Add a date-tree entry in the current file. Interactive version."
  (interactive "P")
  (let ((d (calendar-gregorian-from-absolute
            (if arg
                ;; Current date, possibly corrected for late night
                ;; workers.
                (org-today)
              (progn;; Prompt for date.
                (let ((prompt-time (org-read-date
                                    nil t nil "Date for tree entry:")))
                  (cond ((and (or (not (boundp 'org-time-was-given))
                                  (not org-time-was-given))
                              (not (= (time-to-days prompt-time) (org-today))))
                         ;; Use 00:00 when no time is given for another
                         ;; date than today?
                         (apply #'encode-time 0 0
                                org-extend-today-until
                                (cl-cdddr (decode-time prompt-time))))
                        ((string-match "\\([^ ]+\\)--?[^ ]+[ ]+\\(.*\\)"
                                       org-read-date-final-answer)
                         ;; Replace any time range by its start.
                         (apply #'encode-time
                                (org-read-date-analyze
                                 (replace-match "\\1 \\2" nil nil
                                                org-read-date-final-answer)
                                 prompt-time (decode-time prompt-time))))
                        (t prompt-time))
                  (time-to-days prompt-time)))))))
    (org-datetree-find-date-create d)))
#+end_src
** cliplink
#+begin_src emacs-lisp
(use-package org-cliplink
  :config
  ;; I don't like titles clipping at 80. I'd rather get the full title
  ;; and edit it manually.
  (setq org-cliplink-max-length 200))
#+end_src
** Refile
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/org-refile-files ()
  (rasen/org-files-in-dir rasen/org-directory))

;; non-nil values work bad with ivy
(setq-default org-refile-use-outline-path 'file)
(setq-default org-outline-path-complete-in-steps nil)

(setq org-refile-targets
      '(;(nil :maxlevel . 3)
        (org-agenda-files :tag . "honeypot")
        (org-agenda-files :tag . "PROJECT")
        (org-agenda-files :maxlevel . 2)
        (rasen/org-refile-files :maxlevel . 1)))
#+end_src
*** Refiling with hydras
Adapted from [[https://mollermara.com/blog/Fast-refiling-in-org-mode-with-hydras/][Fast refiling in org-mode with hydras | Josh Moller-Mara]]. Extended to support refiling by outline path.
#+begin_src emacs-lisp
(require 'hydra)

(defun rasen/concat (sequence separator)
  (mapconcat 'identity sequence separator))

(defun rasen/org-refile-exact (file path &optional arg)
  "Refile to a specific location.

With a `C-u' ARG argument, jump to that location."
  (let* ((pos (org-find-olp (cons file path)))
         (rfloc (list (rasen/concat path "/") file nil pos)))

    (if (and (eq major-mode 'org-agenda-mode)
             ;; Don't use org-agenda-refile if we're just jumping
             (not (and arg (listp arg))))
        (org-agenda-refile nil rfloc)
      (org-refile arg nil rfloc))))

(defun rasen/refile (file path &optional arg)
  "Refile to PATH in FILE. Clean up org-capture if it's activated.

With a `C-u` ARG, just jump to the headline."
  (interactive "P")
  (let ((is-capturing (and (boundp 'org-capture-mode) org-capture-mode)))
    (cond
     ((and arg (listp arg))             ;Are we jumping?
      (rasen/org-refile-exact file path arg))

     ;; Are we in org-capture-mode?
     (is-capturing
      (rasen/org-capture-refile-but-with-args file path arg))

     (t
      (rasen/org-refile-exact file path arg)))

    (when (or arg is-capturing)
      (setq hydra-deactivate t))))

(defun rasen/org-capture-refile-but-with-args (file path &optional arg)
  "Copied from `org-capture-refile' since it doesn't allow passing arguments. This does."
  (unless (eq (org-capture-get :type 'local) 'entry)
    (error
     "Refiling from a capture buffer makes only sense for `entry'-type templates"))
  (let ((pos (point))
        (base (buffer-base-buffer (current-buffer)))
        (org-capture-is-refiling t)
        (kill-buffer (org-capture-get :kill-buffer 'local)))
    (org-capture-put :kill-buffer nil)
    (org-capture-finalize)
    (save-window-excursion
      (with-current-buffer (or base (current-buffer))
        (org-with-wide-buffer
         (goto-char pos)
         (rasen/org-refile-exact file path arg))))
    (when kill-buffer (kill-buffer base))))

(defmacro rasen/make-refile-hydra (hydraname name &rest options)
  (declare (indent defun))
  `(defhydra ,hydraname (:exit t)
     ,name

     ,@(mapcar (lambda (x)
                 (let ((key  (nth 0 x))
                       (name (nth 1 x))
                       (file (nth 2 x))
                       (path (nthcdr 3 x)))
                   `(,key (rasen/refile ,file ',path current-prefix-arg) ,name)))
               options)

     ("q" nil "cancel")))
#+end_src

Actual configuration.
#+begin_src emacs-lisp
(rasen/make-refile-hydra rasen/org-refile-hydra-projects "Projects"
  ("w" "Work"                   "~/org/ring.org.gpg" "Projects")
  ("p" "Personal"               "~/org/plan.org"     "Projects"))

(rasen/make-refile-hydra rasen/org-refile-hydra-areas "Areas"
  ("w" "Work"                   "~/org/ring.org.gpg" "Work")
  ("h" "Home"                   "~/org/plan.org"     "Areas" "Home")
  ("p" "People"                 "~/org/plan.org"     "Areas" "People")
  ("c" "Computers"              "~/org/plan.org"     "Areas" "Computers")
  ("o" "Open-source"            "~/org/plan.org"     "Areas" "Open-source")
  ("P" "Planning"               "~/org/plan.org"     "Areas" "Planning")
  ("s" "Self-development"       "~/org/plan.org"     "Areas" "Self-development")
  ("H" "Health"                 "~/org/plan.org"     "Areas" "Health")
  ("C" "Cats"                   "~/org/plan.org"     "Areas" "Cats")
  ("e" "egoless.tech"           "~/org/plan.org"     "Areas" "egoless.tech")
  ("a" "alexeyshmalko.com"      "~/org/plan.org"     "Areas" "alexeyshmalko.com")
  ("m" "Misc"                   "~/org/plan.org"     "Areas" "Misc"))

(rasen/make-refile-hydra rasen/org-refile-hydra-resources "Resources"
  ("w" "Work"                   "~/org/ring.org.gpg" "Resources")
  ("p" "Productivity"           "~/org/plan.org"     "Resources" "Productivity")
  ("s" "Software development"   "~/org/plan.org"     "Resources" "Software development, programming, architecture")
  ("f" "Future of Software"     "~/org/plan.org"     "Resources" "Future of Software")
  ("M" "Management"             "~/org/plan.org"     "Resources" "Management")
  ("a" "Martial Arts"           "~/org/plan.org"     "Resources" "Martial Arts")
  ("n" "Natural sciences"       "~/org/plan.org"     "Resources" "Natural sciences")
  ("d" "Design"                 "~/org/plan.org"     "Resources" "Design")
  ("l" "Programming languages"  "~/org/plan.org"     "Resources" "Programming languages")
  ("W" "Writing"                "~/org/plan.org"     "Resources" "Writing")
  ("c" "Communication"          "~/org/plan.org"     "Resources" "Communication")
  ("b" "Business"               "~/org/plan.org"     "Resources" "Business")
  ("g" "Gamedev"                "~/org/plan.org"     "Resources" "Gamedev")
  ("m" "Misc"                   "~/org/plan.org"     "Resources" "Misc"))

(defhydra rasen/org-refile-hydra (:foreign-keys run :exit t)
  "Refile"
  ("p" rasen/org-refile-hydra-projects/body "Projects")
  ("a" rasen/org-refile-hydra-areas/body "Areas")
  ("r" rasen/org-refile-hydra-resources/body "Resources")

  ("w" (if (eq major-mode 'org-agenda-mode)
           (org-agenda-refile current-prefix-arg)
         (org-refile current-prefix-arg))
   "select")

  ("q" nil "cancel"))

(leader-def 'normal 'org-mode-map         "w" #'rasen/org-refile-hydra/body)
(leader-def 'motion 'org-agenda-mode-map  "w" #'rasen/org-refile-hydra/body)
(leader-def 'normal 'org-capture-mode-map "w" #'rasen/org-refile-hydra/body)
#+end_src
*** Refile last but *before* archive
I like my archive sibling to be the last child. The default org-refile ignores that at refiles all entries *after* archive.

So here is a little patch to refile before archive sibling if it is present.
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/org-goto-last-child ()
  "Goto the last child, even if it is invisible.
Return t when a child was found.  Otherwise don't move point and return nil."
  (when (org-goto-first-child)
    (while (org-goto-sibling))
    t))

(defun rasen/org-goto-last-archive ()
  (and (rasen/org-goto-last-child)
       (string= org-archive-sibling-heading (org-get-heading t t t t))
       (member org-archive-tag (org-get-tags))
       (point)))

(require 'org-archive) ; for org-archive-sibling-heading

(el-patch-feature org)
(el-patch-defun org-refile (&optional arg default-buffer rfloc msg)
  "Move the entry or entries at point to another heading.

The list of target headings is compiled using the information in
`org-refile-targets', which see.

At the target location, the entry is filed as a subitem of the
target heading.  Depending on `org-reverse-note-order', the new
subitem will either be the first or the last subitem.

If there is an active region, all entries in that region will be
refiled.  However, the region must fulfill the requirement that
the first heading sets the top-level of the moved text.

With a `\\[universal-argument]' ARG, the command will only visit the target \
location
and not actually move anything.

With a prefix `\\[universal-argument] \\[universal-argument]', go to the \
location where the last
refiling operation has put the subtree.

With a numeric prefix argument of `2', refile to the running clock.

With a numeric prefix argument of `3', emulate `org-refile-keep'
being set to t and copy to the target location, don't move it.
Beware that keeping refiled entries may result in duplicated ID
properties.

RFLOC can be a refile location obtained in a different way.  It
should be a list with the following 4 elements:

1. Name - an identifier for the refile location, typically the
headline text
2. File - the file the refile location is in
3. nil - used for generating refile location candidates, not
needed when passing RFLOC
4. Position - the position in the specified file of the
headline to refile under

MSG is a string to replace \"Refile\" in the default prompt with
another verb.  E.g. `org-copy' sets this parameter to \"Copy\".

See also `org-refile-use-outline-path'.

If you are using target caching (see `org-refile-use-cache'), you
have to clear the target cache in order to find new targets.
This can be done with a `0' prefix (`C-0 C-c C-w') or a triple
prefix argument (`C-u C-u C-u C-c C-w')."
  (interactive "P")
  (if (member arg '(0 (64)))
      (org-refile-cache-clear)
    (let* ((actionmsg (cond (msg msg)
                            ((equal arg 3) "Refile (and keep)")
                            (t "Refile")))
           (regionp (org-region-active-p))
           (region-start (and regionp (region-beginning)))
           (region-end (and regionp (region-end)))
           (org-refile-keep (if (equal arg 3) t org-refile-keep))
           pos it nbuf file level reversed)
      (setq last-command nil)
      (when regionp
        (goto-char region-start)
        (beginning-of-line)
        (setq region-start (point))
        (unless (or (org-kill-is-subtree-p
                     (buffer-substring region-start region-end))
                    (prog1 org-refile-active-region-within-subtree
                      (let ((s (point-at-eol)))
                        (org-toggle-heading)
                        (setq region-end (+ (- (point-at-eol) s) region-end)))))
          (user-error "The region is not a (sequence of) subtree(s)")))
      (if (equal arg '(16))
          (org-refile-goto-last-stored)
        (when (or
               (and (equal arg 2)
                    org-clock-hd-marker (marker-buffer org-clock-hd-marker)
                    (prog1
                        (setq it (list (or org-clock-heading "running clock")
                                       (buffer-file-name
                                        (marker-buffer org-clock-hd-marker))
                                       ""
                                       (marker-position org-clock-hd-marker)))
                      (setq arg nil)))
               (setq it
                     (or rfloc
                         (let (heading-text)
                           (save-excursion
                             (unless (and arg (listp arg))
                               (org-back-to-heading t)
                               (setq heading-text
                                     (replace-regexp-in-string
                                      org-link-bracket-re
                                      "\\2"
                                      (or (nth 4 (org-heading-components))
                                          ""))))
                             (org-refile-get-location
                              (cond ((and arg (listp arg)) "Goto")
                                    (regionp (concat actionmsg " region to"))
                                    (t (concat actionmsg " subtree \""
                                               heading-text "\" to")))
                              default-buffer
                              (and (not (equal '(4) arg))
                                   org-refile-allow-creating-parent-nodes)))))))
          (setq file (nth 1 it)
                pos (nth 3 it))
          (when (and (not arg)
                     pos
                     (equal (buffer-file-name) file)
                     (if regionp
                         (and (>= pos region-start)
                              (<= pos region-end))
                       (and (>= pos (point))
                            (< pos (save-excursion
                                     (org-end-of-subtree t t))))))
            (error "Cannot refile to position inside the tree or region"))
          (setq nbuf (or (find-buffer-visiting file)
                         (find-file-noselect file)))
          (if (and arg (not (equal arg 3)))
              (progn
                (pop-to-buffer-same-window nbuf)
                (goto-char (cond (pos)
                                 ((org-notes-order-reversed-p) (point-min))
                                 (t (point-max))))
                (org-show-context 'org-goto))
            (if regionp
                (progn
                  (org-kill-new (buffer-substring region-start region-end))
                  (org-save-markers-in-region region-start region-end))
              (org-copy-subtree 1 nil t))
            (with-current-buffer (setq nbuf (or (find-buffer-visiting file)
                                                (find-file-noselect file)))
              (setq reversed (org-notes-order-reversed-p))
              (org-with-wide-buffer
               (if pos
                   (progn
                     (goto-char pos)
                     (setq level (org-get-valid-level (funcall outline-level) 1))
                     (goto-char
                      (if reversed
                          (or (outline-next-heading) (point-max))
                        (or (el-patch-add (save-excursion (rasen/org-goto-last-archive)))
                            (save-excursion (org-get-next-sibling))
                            (org-end-of-subtree t t)
                            (point-max)))))
                 (setq level 1)
                 (if (not reversed)
                     (goto-char (point-max))
                   (goto-char (point-min))
                   (or (outline-next-heading) (goto-char (point-max)))))
               (unless (bolp) (newline))
               (org-paste-subtree level nil nil t)
               (cond
                ((not org-log-refile))
                (regionp
                 (org-map-region
                  (lambda nil
                    (org-add-log-setup 'refile nil nil 'time))
                  (point)
                  (+
                   (point)
                   (- region-end region-start))))
                (t
                 (org-add-log-setup 'refile nil nil org-log-refile)))
               (and org-auto-align-tags
                    (let ((org-loop-over-headlines-in-active-region nil))
                      (org-align-tags)))
               (let ((bookmark-name (plist-get org-bookmark-names-plist
                                               :last-refile)))
                 (when bookmark-name
                   (with-demoted-errors
                       (bookmark-set bookmark-name))))
               ;; If we are refiling for capture, make sure that the
               ;; last-capture pointers point here
               (when (bound-and-true-p org-capture-is-refiling)
                 (let ((bookmark-name (plist-get org-bookmark-names-plist
                                                 :last-capture-marker)))
                   (when bookmark-name
                     (with-demoted-errors
                         (bookmark-set bookmark-name))))
                 (move-marker org-capture-last-stored-marker (point)))
               (when (fboundp 'deactivate-mark) (deactivate-mark))
               (run-hooks 'org-after-refile-insert-hook)))
            (unless org-refile-keep
              (if regionp
                  (delete-region (point) (+ (point) (- region-end region-start)))
                (org-preserve-local-variables
                 (delete-region
                  (and (org-back-to-heading t) (point))
                  (min (1+ (buffer-size)) (org-end-of-subtree t t) (point))))))
            (when (featurep 'org-inlinetask)
              (org-inlinetask-remove-END-maybe))
            (setq org-markers-to-move nil)
            (message "%s to \"%s\" in file %s: done" actionmsg
                     (car it)
                     file)))))))
#+end_src
** Archive
#+name: org-config
#+begin_src emacs-lisp
(setq-default org-archive-default-command 'org-archive-to-archive-sibling)
#+end_src
** Agenda
Set my org files location.
#+name: org-config
#+begin_src emacs-lisp
(setq org-directory "~/org"
      org-default-notes-file rasen/org-refile-file
      org-agenda-files (rasen/org-files-in-dir "~/org"))
#+end_src

Configure my agenda view.
#+name: org-config
#+begin_src emacs-lisp
(setq org-agenda-span 6)
#+end_src

Configure stuck projects.
#+name: org-config
#+begin_src emacs-lisp
(add-to-list 'org-tags-exclude-from-inheritance "PROJECT")
(setq org-stuck-projects
      '("+PROJECT/-TODO-DONE-CANCELED-WAIT" ("NEXT" "WAIT") nil ""))
#+end_src

#+begin_src emacs-lisp
(use-package org-super-agenda
  :config
  (general-def org-super-agenda-header-map
    "k" #'org-agenda-next-line
    "j" #'org-agenda-previous-line)
  (setq org-agenda-sticky t)
  (setq org-agenda-block-separator nil
        org-agenda-compact-blocks t
        org-agenda-time-grid '((daily today require-timed) nil "......"  "----------------"))
  (setq rasen/org-agenda-work-files (mapcar (lambda (x) (expand-file-name x rasen/org-directory))
                                            '("ring.org.gpg"
                                              "refile-AlexeyShmalko.org")))
  (setq rasen/org-agenda-personal-files (seq-filter (lambda (x) (not (member x rasen/org-agenda-work-files)))
                                                    org-agenda-files))
  (setq org-agenda-custom-commands
        '(("o" "Overview"
           ((agenda "" ((org-agenda-span 6)
                        (org-agenda-files rasen/org-agenda-personal-files)
                        (org-super-agenda-groups
                         '((:habit t
                            :order 10)
                           (:name "Work"
                            :category "work"
                            :tag "work"
                            :order 2)
                           (:name none
                            :time-grid t
                            :anything t)
                           ))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-files rasen/org-agenda-personal-files)
                         (org-super-agenda-groups
                          '((:discard (:scheduled t))
                            (:name "Books"
                             :and (:category "books"
                                   :todo "NEXT")
                             :order 11)
                            (:name "Projects"
                             :and (:tag "PROJECT"
                                   :todo "NEXT")
                             :order 9)
                            (:name "Next"
                             :todo "NEXT"
                             :order 8)
                            (:todo "WAIT"
                             :order 12)
                            (:discard (:anything t))))))

            (search "+{:CREATED:}" ((org-agenda-files (mapcar (lambda (x) (concat rasen/org-directory "/" x))
                                                              '("refile-omicron.org"
                                                                "orgzly.org")))
                                    (org-agenda-overriding-header "")
                                    (org-super-agenda-groups
                                     '((:name "Inbox"
                                        :auto-category t
                                        :anything t)))))))
          ("w" "Work"
           ((agenda "" ((org-agenda-span 6)
                        (org-agenda-files rasen/org-agenda-work-files)
                        ;; (org-super-agenda-groups
                        ;;  '((:name none
                        ;;     :time-grid t
                        ;;     :anything t)
                        ;;    )))
                        ))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-files rasen/org-agenda-work-files)
                         (org-super-agenda-groups
                          '((:discard (:scheduled t))
                            (:name "Projects"
                             :and (:tag "PROJECT"
                                   :todo "NEXT")
                             :order 9)
                            (:name "Next"
                             :todo "NEXT"
                             :order 8)
                            (:todo "WAIT"
                             :order 12)
                            (:discard (:anything t))))))

            (search "+{:CREATED:}" ((org-agenda-files (mapcar (lambda (x) (expand-file-name x rasen/org-directory))
                                                              '("refile-AlexeyShmalko.org")))
                                    (org-agenda-overriding-header "")
                                    (org-super-agenda-groups
                                     '((:name "Inbox"
                                        :auto-category t
                                        :anything t)))))))

          ("N" tags "+TODO=\"NEXT\"-PROJECT|+TODO=\"WAIT\"-PROJECT")
          ("n" todo-tree "NEXT")
          ("p" "active projects" tags "+PROJECT/+NEXT")
          ("P" "all projects" tags "+PROJECT/-DONE-CANCELED")))
  (org-super-agenda-mode))
#+end_src
*** Allow NEXT projects to stuck
=org-agenda-list-stuck-projects= marks project as unstuck if its header matches any of specified keywords. This makes all =NEXT= projects automatically unstuck.

Fix this by skipping the first line (project title) in =org-agenda-skip-function=.
#+begin_src emacs-lisp
(el-patch-feature org-agenda)
(el-patch-defun org-agenda-list-stuck-projects (&rest ignore)
  "Create agenda view for projects that are stuck.
Stuck projects are project that have no next actions.  For the definitions
of what a project is and how to check if it stuck, customize the variable
`org-stuck-projects'."
  (interactive)
  (let* ((org-agenda-overriding-header
          (or org-agenda-overriding-header "List of stuck projects: "))
         (matcher (nth 0 org-stuck-projects))
         (todo (nth 1 org-stuck-projects))
         (tags (nth 2 org-stuck-projects))
         (gen-re (org-string-nw-p (nth 3 org-stuck-projects)))
         (todo-wds
          (if (not (member "*" todo)) todo
            (org-agenda-prepare-buffers (org-agenda-files nil 'ifmode))
            (org-delete-all org-done-keywords-for-agenda
                            (copy-sequence org-todo-keywords-for-agenda))))
         (todo-re (and todo
                       (format "^\\*+[ \t]+\\(%s\\)\\>"
                               (mapconcat #'identity todo-wds "\\|"))))
         (tags-re (cond ((null tags) nil)
                        ((member "*" tags) org-tag-line-re)
                        (tags
                         (let ((other-tags (format "\\(?:%s:\\)*" org-tag-re)))
                           (concat org-outline-regexp-bol
                                   ".*?[ \t]:"
                                   other-tags
                                   (regexp-opt tags t)
                                   ":" other-tags "[ \t]*$")))
                        (t nil)))
         (re-list (delq nil (list todo-re tags-re gen-re)))
         (skip-re
          (if (null re-list)
              (error "Missing information to identify unstuck projects")
            (mapconcat #'identity re-list "\\|")))
         (org-agenda-skip-function
          ;; Skip entry if `org-agenda-skip-regexp' matches anywhere
          ;; in the subtree.
          `(lambda ()
             (and (save-excursion
                    (let ((case-fold-search nil)
                          (el-patch-add (subtree-end (save-excursion (org-end-of-subtree t)))))
                      (el-patch-add (forward-line))
                      (re-search-forward
                       ,skip-re
                       (el-patch-swap
                         (save-excursion (org-end-of-subtree t))
                         subtree-end)
                       t)))
                  (progn (outline-next-heading) (point))))))
    (org-tags-view nil matcher)
    (setq org-agenda-buffer-name (buffer-name))
    (with-current-buffer org-agenda-buffer-name
      (setq org-agenda-redo-command
            `(org-agenda-list-stuck-projects ,current-prefix-arg))
      (let ((inhibit-read-only t))
        (add-text-properties
         (point-min) (point-max)
         `(org-redo-cmd ,org-agenda-redo-command))))))
#+end_src
** Babel
Code-hightlight (fontify) org-babel (=#+begin_src=) blocks.

#+name: org-config
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src

Do not confirm evaluation for emacs-lisp.
#+name: org-config
#+begin_src emacs-lisp
(defun rasen/org-confirm-babel-evaluate (lang body)
  (not (member lang '("emacs-lisp"))))

(setq org-confirm-babel-evaluate 'rasen/org-confirm-babel-evaluate)
#+end_src
** Latex preview
#+name: org-config
#+begin_src emacs-lisp
(setq org-latex-packages-alist
      '(;; Use mhchem for chemistry formulas
        ("" "mhchem" t)
        ;; Use tikz-cd for category theory formulas
        ("" "tikz-cd" t)))

;; Store all preview in external directory
(setq org-preview-latex-image-directory (expand-file-name "cache/ltximg/" user-emacs-directory))

;; Use imagemagick instead of dvipng (dvipng does not work with tikz)
(setq org-preview-latex-default-process 'imagemagick)

;; Enable latex preview by default
(setq org-startup-with-latex-preview t)

;; The latest imagemagick incorrectly trims images when density is
;; odd. My density is 277. Hard-code -density option to the closest
;; even number, so latex images are properly trimmed.
(plist-put (alist-get 'imagemagick org-preview-latex-process-alist)
           :image-converter '("convert -density 278 -trim -antialias %f -quality 100 %O"))
#+end_src
** Image preview
#+name: org-config
#+begin_src emacs-lisp
;; Scale inline images by default
(setq org-image-actual-width '(1024))
;; Show inline images by default
(setq org-startup-with-inline-images t)
#+end_src
** Export
Fix exporting for confluence.

=ox-confluence= has an issue with verbatim---it doesn't redefine verbatim translation, so =org-ascii-verbatim= is used. The following makes =org-ascii-verbatim= produce proper confluence fixed-width block.
#+name: org-config
#+begin_src emacs-lisp
(add-to-list 'org-modules 'ox-confluence)
(setq org-ascii-verbatim-format "\{\{%s\}\}")

(defun rasen/org-ox-confluence ()
  (interactive)
  (save-excursion
    (save-restriction
      (when (region-active-p)
        (narrow-to-region (region-beginning) (region-end)))

      (goto-char (point-min))
      (perform-replace "-" "&#45;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       )
      (goto-char (point-min))
      (perform-replace "_" "&#95;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       )
      (goto-char (point-min))
      (perform-replace "{" "&#123;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       )
      (goto-char (point-min))
      (perform-replace "}" "&#125;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       )
      (goto-char (point-min))
      (perform-replace "[" "&#91;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       )
      (goto-char (point-min))
      (perform-replace "]" "&#93;"
                       nil              ; replace all
                       nil              ; not regex
                       nil              ; replace on word boundaries
                       ))))

(setq rasen/confluence-block-known-languages
      '("actionscript3"
        "applescript"
        "bash"
        "c#"
        "cpp"
        "css"
        "coldfusion"
        "delphi"
        "diff"
        "erl" ; Erlang
        "groovy"
        "xml" ; and HTML
        "java"
        "jfx" ; Java FX
        "js"
        "php"
        "perl"
        "text"
        "powershell"
        "py"
        "ruby"
        "sql"
        "sass"
        "scala"
        "vb" ; Visual Basic
        "yml"))

(require 'ox-confluence)
(el-patch-defun org-confluence--block (language theme contents)
  (concat (el-patch-swap "\{code:theme=" "\{code") (el-patch-remove theme)
          (when (el-patch-swap language (member language rasen/confluence-block-known-languages)) (format (el-patch-swap "|language=%s" ":language=%s") language))
          "}\n"
          contents
          "\{code\}\n"))
#+end_src
** Crypt
Allow encrypted entries in org files.
#+name: org-config
#+begin_src emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(add-to-list 'org-tags-exclude-from-inheritance "crypt")
(setq org-crypt-key "rasen.dubi@gmail.com")
(add-hook 'org-babel-pre-tangle-hook 'org-decrypt-entries t)
#+end_src
** Habits
#+name: org-config
#+begin_src emacs-lisp
(require 'org-habit)
(setq org-habit-show-habits-only-for-today t)
(setq org-habit-preceding-days 25)
(setq org-habit-following-days 3)
#+end_src
** adaptive-wrap
Better line wrapping. (Use proper wrap-prefix in lists, etc.)
#+begin_src emacs-lisp
(use-package adaptive-wrap
  :config
  (add-hook 'org-mode-hook #'adaptive-wrap-prefix-mode))
#+end_src
** org-roam
#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :diminish
  :hook
  (after-init . org-roam-mode)

  :general
  (s-leader-def
    "n r" #'org-roam
    "n f" #'org-roam-find-file
    "n b" #'org-roam-switch-to-buffer)
  (:keymaps 'org-mode-map
   :states '(insert visual)
   "C-c i" #'org-roam-insert
   ;; C-i is interpreted as TAB
   "C-c TAB" #'org-roam-insert)

  :config
  (require 'org-roam-protocol)

  (setq org-roam-directory (concat rasen/org-directory "/roam")
        ;; move `org-roam-db-location' off roam directory, so syncthing does not sync it
        org-roam-db-location (expand-file-name "cache/org-roam.db" user-emacs-directory)
        org-roam-index-file "index.org")

  ;; Submitted at https://github.com/org-roam/org-roam/pull/851
  (defun org-roam--extract-tags-first-directory (file)
    "Extract tags from path FILE. The first directory component after `org-roam-directory' is used as a tag."
    (when-let ((dir-relative (file-name-directory
                              (file-relative-name file org-roam-directory))))
      (list (car (f-split dir-relative)))))

  (setq org-roam-tag-sources '(prop first-directory))

  (defconst rasen/slip-boxes
    '(;; Default slip-box with permanent notes
      ("d" "default"     "")

      ;; "Life project"—everything that doesn't fit in other slip
      ;; boxes. Examples are: my gratitude journal, small projects,
      ;; article drafts, idea list.
      ("l" "life"        "life/")

      ;; Work notes
      ("r" "ring"        "ring/")

      ;; Literature notes
      ("" "literature"   "biblio/"))
    "My Zettelkasten slip boxes. Format is a list of (capture-key name directory).")

  (defun rasen/roam-rename (new-name)
    "Move file to NEW-NAME. `org-roam' takes care of adjusting all links."
    (let ((filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting file!" (buffer-name)))
      (rename-file filename new-name)
      (set-visited-file-name new-name t)
      (revert-buffer t t t)
      ;; trigger save-buffer for org-roam to regenerate `org-roam-buffer'.
      (set-buffer-modified-p t)
      (save-buffer)))

  (defun rasen/move-to-slip-box (slip-box)
    "Move file to specified SLIP-BOX."
    (interactive (list (completing-read "Move to slip-box: "
                                        (mapcar (lambda (x) (nth 2 x)) rasen/slip-boxes))))
    (let* ((filename (buffer-file-name))
           (directory (file-name-directory filename))
           (name (file-name-nondirectory filename))
           (new-name (f-join org-roam-directory slip-box name)))
      (rasen/roam-rename new-name)))

  ;; exclude non-default slip-boxes from graph
  (setq org-roam-graph-exclude-matcher
        (seq-filter (lambda (x) (not (string-empty-p x)))
                    (mapcar (lambda (x) (nth 2 x)) rasen/slip-boxes)))

  ;; one capture template per slip-box
  (setq org-roam-capture-templates
        (mapcar (lambda (x)
                  (let ((key  (nth 0 x))
                        (name (nth 1 x))
                        (dir  (nth 2 x)))
                    `(,key ,name plain (function org-roam--capture-get-point) "%?"
                           :file-name ,(concat dir "%(rasen/tsid)")
                           :head "#+TITLE: ${title}\n"
                           :unnarrowed t)))
                rasen/slip-boxes))

  ;; better defaults for graph view
  ;; (setq org-roam-graph-executable (executable-find "dot"))
  ;; (setq org-roam-graph-executable (executable-find "neato"))
  ;; (setq org-roam-graph-executable (executable-find "fdp"))
  (setq org-roam-graph-executable (executable-find "sfdp"))
  (setq org-roam-graph-extra-config '(;; ("concentrate" . "true")
                                      ("overlap" . "prism")
                                      ;; ("pack" . "false")
                                      ("sep" . "20.0")
                                      ("esep" . "0.01")
                                      ("splines" . "true")))
  (setq org-roam-graph-node-extra-config '(("shape" . "rectangle")))
  (setq org-roam-graph-edge-extra-config '(("dir" . "back")))

  ;; patch function to use kebab-case in file names
  (el-patch-defun org-roam--title-to-slug (title)
    "Convert TITLE to a filename-suitable slug."
    (cl-flet* ((nonspacing-mark-p (char)
                                  (eq 'Mn (get-char-code-property char 'general-category)))
               (strip-nonspacing-marks (s)
                                       (apply #'string (seq-remove #'nonspacing-mark-p
                                                                   (ucs-normalize-NFD-string s))))
               (cl-replace (title pair)
                           (replace-regexp-in-string (car pair) (cdr pair) title)))
      (let* ((pairs `(el-patch-swap (("[^[:alnum:][:digit:]]" . "_") ;; convert anything not alphanumeric
                                     ("__*" . "_")  ;; remove sequential underscores
                                     ("^_" . "")    ;; remove starting underscore
                                     ("_$" . ""))   ;; remove ending underscore
                                    (("[^[:alnum:][:digit:]]" . "-") ;; convert anything not alphanumeric
                                     ("--*" . "-")  ;; remove sequential dashes
                                     ("^-" . "")    ;; remove starting dash
                                     ("-$" . "")))) ;; remove ending dash
             (slug (-reduce-from #'cl-replace (strip-nonspacing-marks title) pairs)))
        (downcase slug))))

  (defun rasen/refile-weight ()
    "Refile current item as weight log."
    (interactive)
    (save-excursion
      (save-window-excursion
        (rasen/org-copy-log-entry t)
        (org-roam-find-file "(life) My Weight" nil nil t)
        (goto-char (point-max))
        (yank))))

  (defun rasen/refile-gratitude ()
    (interactive)
    (save-excursion
      (save-window-excursion
        (let* ((element (org-element-at-point))
               (created (org-element-property :CREATED element))
               (cbeg (org-element-property :contents-begin element))
               (cend (org-element-property :contents-end element))
               (contents (buffer-substring cbeg cend)))
          (org-cut-subtree)
          (current-kill 1)

          (org-roam-find-file "(life) My Gratitude Journal" nil nil t)
          (org-datetree-find-date-create
           (calendar-gregorian-from-absolute
            (time-to-days (org-read-date nil t created))))

          (next-line)
          (insert contents))))))
#+end_src

Enable auto-completion for notes.
#+begin_src emacs-lisp
(use-package company-org-roam
  :after org org-roam company
  :config
  (push #'company-org-roam company-backends))
#+end_src
** org-ref
#+begin_src emacs-lisp
(use-package ivy-bibtex
  :config
  (defun rasen/ivy-cite ()
    (interactive)
    (let ((ivy-bibtex-default-action #'ivy-bibtex-insert-citation))
      (call-interactively #'ivy-bibtex))))
(use-package org-ref
  :after org-roam
  :config
  (let* ((bib-file-name '("books.bib" "papers.bib" "online.bib"))
         (bib-directory (expand-file-name "biblio" org-roam-directory))
         (bib-files-directory (expand-file-name "files/" bib-directory))
         (bib-files (mapcar (lambda (x) (expand-file-name x bib-directory)) bib-file-name)))

    (setq reftex-default-bibliography bib-files)
    (setq org-ref-default-bibliography bib-files)
    (setq bibtex-completion-bibliography bib-files)

    (setq org-ref-bibliography-notes bib-directory)
    (setq bibtex-completion-notes-path bib-directory)

    (setq org-ref-pdf-directory bib-files-directory)
    (setq bibtex-completion-library-path `(,bib-files-directory)))

  (require 'org-ref-url-utils)
  (require 'org-ref-isbn)
  (general-def 'normal 'bibtex-mode-map
    "C-c C-c" #'org-ref-clean-bibtex-entry
    "C-c c"   #'org-ref-clean-bibtex-entry
    "C-c s"   #'bibtex-sort-buffer
    "C-c n"   #'org-ref-open-bibtex-notes

    ;; (a)ttach pdf
    "C-c a"   #'org-ref-bibtex-assoc-pdf-with-entry
    "C-c f"   #'org-ref-bibtex-pdf

    ;; (o)nline
    "C-c o"   #'org-ref-url-html-to-bibtex
    "C-c i"   #'isbn-to-bibtex)

  (setq org-ref-completion-library 'org-ref-ivy-cite)

  ;; Rules for automatic key generation
  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator ""
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 5
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5)

  (setq bibtex-dialect 'biblatex)

  ;; `isbn-to-bibtex' fails with "(wrong-type-argument stringp nil)"
  ;; error down in `org-ref-isbn-clean-bibtex-entry' functions. This
  ;; happens because temporary buffer is not in `bibtex-mode', so
  ;; `bibtex-entry-head' variable is not set.
  ;;
  ;; Prepend `bibtex-mode' to the list of processors, so the next ones
  ;; work correctly.
  (add-hook 'org-ref-isbn-clean-bibtex-entry-hook #'bibtex-mode)

  ;; Do not fill entries. (It works badly with urls.)
  (el-patch-defun bibtex-fill-field-bounds (bounds justify &optional move)
    "Fill BibTeX field delimited by BOUNDS.
If JUSTIFY is non-nil justify as well.
If optional arg MOVE is non-nil move point to end of field."
    (let ((end-field (copy-marker (bibtex-end-of-field bounds))))
      (if (not justify)
          (goto-char (bibtex-start-of-text-in-field bounds))
        (goto-char (bibtex-start-of-field bounds))
        (forward-char) ; leading comma
        (bibtex-delete-whitespace)
        (insert "\n")
        (indent-to-column (+ bibtex-entry-offset
                             bibtex-field-indentation))
        (re-search-forward "[ \t\n]*=" end-field)
        (replace-match "=")
        (forward-char -1)
        (if bibtex-align-at-equal-sign
            (indent-to-column
             (+ bibtex-entry-offset (- bibtex-text-indentation 2)))
          (insert " "))
        (forward-char)
        (bibtex-delete-whitespace)
        (if bibtex-align-at-equal-sign
            (insert " ")
          (indent-to-column bibtex-text-indentation)))
      (el-patch-remove
        ;; Paragraphs within fields are not preserved.  Bother?
        (fill-region-as-paragraph (line-beginning-position) end-field
                                  default-justification nil (point)))
      (if move (goto-char end-field)))))
#+end_src
** org-roam-bibtex
Citations and bibliography tools for org-mode.
#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :diminish
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (setq orb-templates
        `(("r" "ref" plain #'org-roam-capture--get-point ""
           :file-name "biblio/${slug}"
           :head
           ,(concat "#+TITLE: ${title}\n"
                    "#+ROAM_KEY: ${ref}\n")
           :unnarrowed t))))
#+end_src
** toc-org
Generate Table of Contents for this file.

#+begin_src emacs-lisp
(use-package toc-org
  :commands (toc-org-mode toc-org-insert-toc))
#+end_src
** org-fc
Flashcards/spaced repetition system for org-mode. It works with many files better than org-drill (and many files is what I have with org-roam).

#+begin_src emacs-lisp
(use-package org-fc
  :config
  (require 'org-fc-keymap-hint)

  (setq org-fc-directories (list (expand-file-name "roam" rasen/org-directory)))
  (setq org-fc-review-history-file (expand-file-name "org-fc-history.tsv" rasen/org-directory))

  ;; (setq org-fc-stats-review-min-box 2)

  (el-patch-defun org-fc-index-flatten-card (card)
    "Flatten CARD into a list of positions.
Relevant data from the card is included in each position
element."
    (mapcar
     (lambda (pos)
       (list
        :filetitle (plist-get card :filetitle)
        :tags (plist-get card :tags)
        :path (plist-get card :path)
        :id (plist-get card :id)
        (el-patch-add :suspended (plist-get card :suspended))
        :type (plist-get card :type)
        :due (plist-get pos :due)
        :position (plist-get pos :position)))
     (plist-get card :positions)))

  (defun rasen/org-fc-upcoming-histogram (&optional context)
    "Draw a histogram of upcoming review."
    (interactive (list (org-fc-select-context)))
    (let* ((positions (seq-filter (lambda (x)
                                    (not (plist-get x :suspended)))
                                  (org-fc-index-positions (org-fc-index (or context 'all)))))
           (total (length positions))
           (sorted (seq-sort
                    (lambda (x y) (time-less-p
                                   (plist-get x :due)
                                   (plist-get y :due)))
                    positions))
           (next-review (plist-get (car sorted) :due))
           (next-review-diff (time-to-seconds (time-subtract next-review nil)))
           (grouped (seq-group-by
                     (lambda (x)
                       (format-time-string "%F" (plist-get x :due)))
                     sorted))
           (grouped-count (mapcar (lambda (x)
                                    (cons (car x) (length (cdr x))))
                                  grouped)))
      (with-output-to-temp-buffer "*org-fc-upcoming*"
        (princ (format-time-string "Next review: %F %T" next-review))
        (if (> next-review-diff 0)
            (princ (format " (in %s)\n" (format-seconds "%D %H %z%M" next-review-diff)))
          (princ " (ready)\n"))
        (princ (format "Total positions: %s\n\n" total))
        (princ "Upcoming reviews:\n")
        (mapc
         (lambda (x)
           (princ (car x))
           (princ (format " %3s " (cdr x)))
           (princ (make-string (cdr x) ?+))
           (princ "\n"))
         grouped-count))
      (switch-to-buffer-other-window "*org-fc-upcoming*")))

  (general-define-key
   :definer 'minor-mode
   :states 'normal
   :keymaps 'org-fc-review-flip-mode
   "RET" 'org-fc-review-flip
   "n" 'org-fc-review-flip
   "s" 'org-fc-review-suspend-card
   "q" 'org-fc-review-quit)

  (general-define-key
   :definer 'minor-mode
   :states 'normal
   :keymaps 'org-fc-review-rate-mode
   "a" 'org-fc-review-rate-again
   "h" 'org-fc-review-rate-hard
   "g" 'org-fc-review-rate-good
   ;; There seems to be an issue binding "g" and it still behaves as
   ;; a prefix for other commands in rate mode.
   ;;
   ;; Bind `org-fc-review-rate-good' to "n" as well to workaround
   ;; this.
   "n" 'org-fc-review-rate-good
   "e" 'org-fc-review-rate-easy
   "s" 'org-fc-review-suspend-card
   "q" 'org-fc-review-quit)

  (general-def 'normal 'org-fc-review-edit-mode-map
    "'"   #'org-fc-review-resume)

  (general-def 'normal 'org-fc-dashboard-mode-map
    "r"   #'org-fc-review-dashboard-context
    "g"   (defun rasen/org-fc-dashboard ()
            (interactive)
            (org-fc-dashboard org-fc-context-all))
    "h"   #'rasen/org-fc-upcoming-histogram
    "q"   #'quit-window)

  <<org-fc-review-todos>>)
#+end_src

** org-fc review todos
My modifications to support reviewing arbitrary todo lists with spaced repetition.
#+name: org-fc-review-todos
#+begin_src emacs-lisp
(defcustom rasen/org-fc-todos-context `(:paths (,(expand-file-name "plan.org" rasen/org-directory))
                                        :filter (type "nocard"))
  "Context in which to search for todo cards.")

(defcustom rasen/org-fc-writing-inbox-context `(:paths ("~/org/roam/life/20200907034408.org")
                                                :filter (type "nocard"))
  "Context in which to search for writing inbox cards.")

;; override all to exclude nocard
(setq org-fc-context-all '(:paths all
                           :filter (not (type "nocard"))))
(setq org-fc-context-dashboard org-fc-context-all)

(defvar rasen/org-fc-todos-current-context rasen/org-fc-todos-context)

;; Special org-fc card type with no flipping
(defun org-fc-type-nocard-init ()
  "Mark headline as a no-card."
  (interactive)
  (org-fc--init-card "nocard")
  (org-fc-review-data-update '("single")))

(defun org-fc-type-nocard-setup (_position)
  "Prepare a no-card for review."
  (interactive)
  (org-fc-noop))

(org-fc-register-type
 'nocard
 #'org-fc-type-nocard-setup
 #'org-fc-noop
 #'org-fc-noop)

(defvar rasen/org-fc-todos-current-card nil)
(defun rasen/org-fc-todos-next-card ()
  "Present a single card from the current buffer for review."
  (interactive)
  (save-buffer)
  (let* ((index (org-fc-index rasen/org-fc-todos-current-context))
         (cards (org-fc-index-filter-due index))
         (positions (org-fc-index-shuffled-positions cards)))
    (if (null positions)
        (progn
          (message "No todos due right now")
          (setq rasen/org-fc-todos-current-card nil)
          (setq hydra-deactivate t))
      (rasen/org-fc-todos-present-position (car positions)))))

(defun rasen/org-fc-todos-present-position (card)
  (let* ((path (plist-get card :path))
         (id (plist-get card :id))
         (type (plist-get card :type))
         (position (plist-get card :position)))
    (let ((buffer (find-buffer-visiting path)))
      (with-current-buffer (find-file path)
        (goto-char (point-min))
        (org-fc-id-goto id path)
        (org-reveal)

        (setq rasen/org-fc-todos-current-card card)
        (setq org-fc-timestamp (time-to-seconds (current-time)))))))

(el-patch-defun (el-patch-swap org-fc-review-update-data rasen/org-fc-todos-review-update-data) (path id position rating delta)
  "Update the review data of the card.
Also add a new entry in the review history file.  PATH, ID,
POSITION identify the position that was reviewed, RATING is a
review rating and DELTA the time in seconds between showing and
rating the card."
  (org-fc-with-point-at-entry
   ;; If the card is marked as a demo card, don't log its reviews and
   ;; don't update its review data
   (unless (member org-fc-demo-tag (org-get-tags))
     (let* ((data (org-fc-get-review-data))
            (current (assoc position data #'string=)))
       (unless current
         (error "No review data found for this position"))
       (let ((ease (string-to-number (cl-second current)))
             (box (string-to-number (cl-third current)))
             (interval (string-to-number (cl-fourth current))))
         (el-patch-remove (org-fc-review-history-add
                           (list
                            (org-fc-timestamp-now)
                            path
                            id
                            position
                            (format "%.2f" ease)
                            (format "%d" box)
                            (format "%.2f" interval)
                            (symbol-name rating)
                            (format "%.2f" delta)
                            (symbol-name org-fc-algorithm))))
         (cl-destructuring-bind (next-ease next-box next-interval)
             (org-fc-sm2-next-parameters ease box interval rating)
           (setcdr
            current
            (list (format "%.2f" next-ease)
                  (number-to-string next-box)
                  (format "%.2f" next-interval)
                  (org-fc-timestamp-in next-interval)))
           (org-fc-set-review-data data)))))))

(defun rasen/org-fc-todos-rate (rating)
  "Rate the card at point with RATING."
  (if-let ((card rasen/org-fc-todos-current-card))
      (if (string= (plist-get card :id) (org-id-get))
          (let* ((path (plist-get card :path))
                 (id (plist-get card :id))
                 (position (plist-get card :position))
                 (now (time-to-seconds (current-time)))
                 (delta (- now org-fc-timestamp)))
            (rasen/org-fc-todos-review-update-data path id position rating delta)
            (rasen/org-fc-todos-next-card))
        (message "Flashcard ID mismatch"))
    (message "No todos review is in progress")))
(defun rasen/org-fc-todos-rate-soon ()
  (interactive)
  (rasen/org-fc-todos-rate 'hard))
(defun rasen/org-fc-todos-rate-normal ()
  (interactive)
  (rasen/org-fc-todos-rate 'good))
(defun rasen/org-fc-todos-rate-later ()
  (interactive)
  (rasen/org-fc-todos-rate 'easy))
(defun rasen/org-fc-todos-today ()
  (interactive)
  (save-excursion
    (rasen/org-fc-todos-rate 'again))
  (save-excursion
    (rasen/org-do-today))
  (save-buffer)
  (rasen/org-fc-todos-next-card))

(defun rasen/org-fc-todos-suspend ()
  (interactive)
  (org-fc-suspend-card)
  (save-buffer)
  (rasen/org-fc-todos-next-card))

(defun rasen/org-fc-todos-delete ()
  (interactive)
  (org-cut-subtree)
  (save-buffer)
  (rasen/org-fc-todos-next-card))

(defun rasen/org-fc-todos-update-fc ()
  (when (member org-fc-flashcard-tag (org-get-tags nil 'local))
    (cond
     ((string= "NEXT" org-state) (org-toggle-tag org-fc-suspended-tag 'on))
     ((string= "TODO" org-state) (org-toggle-tag org-fc-suspended-tag 'off))
     ((string= "DONE" org-state) (org-toggle-tag org-fc-suspended-tag 'on)))))

(add-hook 'org-after-todo-state-change-hook #'rasen/org-fc-todos-update-fc)

(defun rasen/org-fc-todos-estimate-next-interval (rating)
  (condition-case err
      (org-fc-with-point-at-entry
       (let* ((data (org-fc-get-review-data))
              (current (assoc (plist-get rasen/org-fc-todos-current-card :position) data #'string=)))
         (let ((ease (string-to-number (cl-second current)))
               (box (string-to-number (cl-third current)))
               (interval (string-to-number (cl-fourth current))))
           (cl-destructuring-bind (next-ease next-box next-interval) (org-fc-sm2-next-parameters ease box interval rating)
             next-interval))))
    (error 0)))

(defun rasen/org-fc-todos-hydra-hint (name rating)
  (format "%s (%.2f days)" name (rasen/org-fc-todos-estimate-next-interval rating)))

(defhydra rasen/hydra-todos-review ()
  "todos review"
  ("q" nil "quit")
  ("s" #'rasen/org-fc-todos-rate-soon   (rasen/org-fc-todos-hydra-hint "soon"   'hard))
  ("n" #'rasen/org-fc-todos-rate-normal (rasen/org-fc-todos-hydra-hint "normal" 'good))
  ("l" #'rasen/org-fc-todos-rate-later  (rasen/org-fc-todos-hydra-hint "later"  'easy))
  ("o" #'org-open-at-point "open")
  ("t" #'rasen/org-fc-todos-today "today")
  ("S" #'rasen/org-fc-todos-suspend "suspend")
  ("d" #'rasen/org-fc-todos-delete "delete"))

(defun rasen/org-fc-todos-review-with-context (ctx)
  (setq rasen/org-fc-todos-current-context ctx)
  (rasen/org-fc-todos-next-card)
  (when rasen/org-fc-todos-current-card
    (rasen/hydra-todos-review/body)))

(defun rasen/todos-review ()
  (interactive)
  (rasen/org-fc-todos-review-with-context rasen/org-fc-todos-context))

(defun rasen/writing-review ()
  (interactive)
  (rasen/org-fc-todos-review-with-context rasen/org-fc-writing-inbox-context))
#+end_src
** toggle markup/view
#+begin_src emacs-lisp
(defun rasen/toggle-org-view-mode ()
  (interactive)
  ;; partially stolen from `org-toggle-link-display'
  (if org-link-descriptive
      (progn
        (remove-from-invisibility-spec '(org-link))
        (setq-local org-hide-emphasis-markers nil)
        (org-clear-latex-preview (point-min) (point-max))
        (org-remove-inline-images)
        (message "org-view-mode disabled"))

    (add-to-invisibility-spec '(org-link))
    (setq org-hide-emphasis-markers t)
    (org--latex-preview-region (point-min) (point-max))
    (org-display-inline-images)
    (message "org-view-mode enabled"))
  (setq-local org-link-descriptive (not org-link-descriptive))
  (font-lock-fontify-buffer))

(leader-def 'normal 'org-mode-map
  "\\" #'rasen/toggle-org-view-mode)
#+end_src
** Evilify org-mode
#+begin_src emacs-lisp
(use-package evil-org
  :after org
  :diminish
  :custom
  ;; swap j/k
  (evil-org-movement-bindings '((up . "j")
                                (down . "k")
                                (left . "h")
                                (right . "l")))
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme)))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)

  ;; when editing code blocks, use current window and do not
  ;; reorganize my frame
  (setq org-src-window-setup 'current-window)

  (general-def 'normal org-mode-map
    "'"        #'org-edit-special
    "C-c '"    (rasen/hard-way "'")
    "go"       #'org-open-at-point
    "C-c C-o"  (rasen/hard-way "go"))

  ;; open file links in the same window
  (push '(file . find-file) org-link-frame-setup)

  (general-def 'normal org-src-mode-map
    "'"      #'org-edit-src-exit
    "C-c '"  (rasen/hard-way "'"))

  (general-def 'motion org-agenda-mode-map
    "k"    #'org-agenda-next-line
    "j"    #'org-agenda-previous-line
    "gk"   #'org-agenda-next-item
    "gj"   #'org-agenda-previous-item
    "C-k"  #'org-agenda-next-item
    "C-j"  #'org-agenda-previous-item

    "K"    #'org-agenda-priority-down
    "J"    #'org-agenda-priority-up

    "M-k"  #'org-agenda-drag-line-forward
    "M-j"  #'org-agenda-drag-line-backward)

  (general-def 'motion org-agenda-mode-map
    "SPC"      nil ;; unset prefix
    "go"       #'org-agenda-open-link
    "gl"       #'org-agenda-log-mode)
  (leader-def 'motion org-agenda-mode-map
    "SPC"  #'org-save-all-org-buffers
    "s"    #'org-agenda-schedule
    "d"    #'org-agenda-deadline
    "w"    #'org-agenda-refile
    "t"    #'org-agenda-todo))
#+end_src
Use emacs-state in org-lint buffers.
#+name: org-config
#+begin_src emacs-lisp
(evil-set-initial-state 'org-lint--report-mode 'emacs)
(evil-set-initial-state 'epa-key-list-mode 'emacs)
#+end_src
* Mail setup
My email load is handled by mbsync (to download email), msmtp (to send mail), and notmuch (to tag and browse it).

Applications are configured with Home Manager, and notmuch frontend is configured in Emacs.
** Applications
#+name: home-manager-section
#+begin_src nix
{
  # Store mails in ~/Mail
  accounts.email.maildirBasePath = "Mail";

  # Use mbsync to fetch email. Configuration is constructed manually
  # to keep my current email layout.
  programs.mbsync = {
    enable = true;
    extraConfig = lib.mkBefore ''
      MaildirStore local
      Path ~/Mail/
      Inbox ~/Mail/INBOX
      SubFolders Verbatim
    '';
  };

  # Notmuch for email browsing, tagging, and searching.
  programs.notmuch = {
    enable = true;
    new.ignore = [
      ".mbsyncstate"
      ".mbsyncstate.lock"
      ".mbsyncstate.new"
      ".mbsyncstate.journal"
      ".uidvalidity"
      "dovecot-uidlist"
      "dovecot-keywords"
      "dovecot.index"
      "dovecot.index.log"
      "dovecot.index.log.2"
      "dovecot.index.cache"
      "/^archive/"
    ];
  };

  # msmtp for sending mail
  programs.msmtp.enable = true;

  # My Maildir layout predates home-manager configuration, so I do not
  # use mbsync config generation from home-manager, to keep layout
  # compatible.
  imports =
    let
      emails = [
        { name = "gmail";   email = "rasen.dubi@gmail.com";    path = "Personal"; primary = true; }
        { name = "ps";      email = "ashmalko@doctoright.org"; path = "protocolstandard"; }
        { name = "egoless"; email = "me@egoless.tech";         path = "egoless"; }
      ];
      mkGmailBox = { name, email, path, ... }@all: {
        accounts.email.accounts.${name} = {
          realName = "Alexey Shmalko";
          address = email;
          flavor = "gmail.com";

          passwordCommand = "pass imap.gmail.com/${email}";
          maildir.path = path;

          msmtp.enable = true;
          notmuch.enable = true;
        } // (removeAttrs all ["name" "email" "path"]);

        programs.mbsync.extraConfig = ''
          IMAPAccount ${name}
          Host imap.gmail.com
          User ${email}
          PassCmd "pass imap.gmail.com/${email}"
          SSLType IMAPS
          CertificateFile /etc/ssl/certs/ca-certificates.crt

          IMAPStore ${name}-remote
          Account ${name}

          Channel sync-${name}-all
          Master :${name}-remote:"[Gmail]/All Mail"
          Slave :local:${path}/all
          Create Both
          SyncState *

          Channel sync-${name}-spam
          Master :${name}-remote:"[Gmail]/Spam"
          Slave :local:${path}/spam
          Create Both
          SyncState *

          Channel sync-${name}-sent
          Master :${name}-remote:"[Gmail]/Sent Mail"
          Slave :local:${path}/sent
          Create Both
          SyncState *

          Group sync-${name}
          Channel sync-${name}-all
          Channel sync-${name}-spam
          Channel sync-${name}-sent
        '';
      };
    in map mkGmailBox emails;
}
#+end_src
** Interface
#+begin_src emacs-lisp
(use-package notmuch
  :config
  (setenv "NOTMUCH_CONFIG" "/home/rasen/.config/notmuch/notmuchrc")
  ;; (setq mm-text-html-renderer 'shr)

  (setq notmuch-archive-tags '("-unread"))
  (setq notmuch-saved-searches
        '(
          (:name "unread-inbox" :query "tag:inbox and tag:unread" :key "u")
          ;; (:name "unread" :query "tag:unread and not tag:nixos and not tag:rust" :key "u")
          (:name "unread-egoless" :query "tag:egoless and tag:unread" :key "e")
          (:name "unread-rust" :query "tag:unread and tag:rust" :key "r")
          (:name "unread-nixos" :query "tag:unread and tag:nixos and not tag:nixpkgs" :key "n")
          (:name "unread-nixpkgs" :query "tag:unread and tag:nixpkgs" :key "p")
          (:name "unread-participating" :query "tag:unread and tag:participating" :key "t")
          (:name "unread-doctoright" :query "tag:unread and tag:doctoright" :key "d")
          (:name "unread-other" :query "tag:unread and not tag:nixos and not tag:inbox and not tag:doctoright and not tag:rust" :key "o")
          (:name "later" :query "tag:later" :key "l")
          (:name "flagged" :query "tag:flagged" :key "F")
          (:name "personal" :query "tag:personal" :key "P")
          (:name "doctoright" :query "tag:doctoright" :key "D")
          (:name "sent" :query "tag:sent" :key "s")
          (:name "drafts" :query "tag:draft" :key "f")
          (:name "all mail" :query "*" :key "a")))
  (setq notmuch-hello-sections
        '(;; notmuch-hello-insert-header
          notmuch-hello-insert-saved-searches
          ;; notmuch-hello-insert-search
          notmuch-hello-insert-alltags
          notmuch-hello-insert-recent-searches
          ;; notmuch-hello-insert-footer
          ))
  (setq-default notmuch-show-indent-content nil)

  (defun rasen/mbsync ()
    (interactive)
    (let ((mbsync-cmd (if (string= (system-name) "omicron")
                          "mbsync sync-gmail & mbsync sync-egoless & mbsync sync-ps & wait; /home/rasen/dotfiles/notmuch.sh"
                        "notmuch new")))
      (async-shell-command mbsync-cmd "*mbsync*")))

  (defun rasen/notmuch-search-mute ()
    (interactive)
    (notmuch-search-tag '("+muted"))
    (notmuch-search-archive-thread))

  (general-def notmuch-hello-mode-map "f" 'rasen/mbsync)

  (general-def
    :keymaps '(notmuch-hello-mode-map
               notmuch-search-mode-map
               notmuch-show-mode-map)
    "g" 'notmuch-refresh-all-buffers)

  (general-def 'notmuch-search-mode-map
    "k" #'notmuch-search-archive-thread
    "m" #'rasen/notmuch-search-mute)
  (general-def 'notmuch-show-mode-map
    "k" #'notmuch-show-archive-thread-then-next)
  ;; remap old function
  (general-def '(notmuch-search-mode-map
                 notmuch-show-mode-map)
    "K" #'notmuch-tag-jump)

  (general-def 'notmuch-show-mode-map
    "C" #'rasen/org-capture-link)

  (general-def 'notmuch-show-mode-map
    "M-u" (lambda ()
            (interactive)
            (notmuch-show-tag '("+unread"))))

  ;; notmuch-tag-formats

  (setq-default notmuch-tagging-keys
                '(("a" notmuch-archive-tags "Archive")
                  ("u" notmuch-show-mark-read-tags "Mark read")
                  ("m" ("+muted") "Mute")
                  ("f" ("+flagged") "Flag")
                  ("s" ("+spam" "-inbox") "Mark as spam")
                  ("d" ("+deleted" "-inbox") "Delete")))

  ;; support for linking notmuch mails in org-mode
  (require 'ol-notmuch))
#+end_src
** Emacs
#+begin_src emacs-lisp
(setq user-full-name "Alexey Shmalko"
      user-mail-address "rasen.dubi@gmail.com")
#+end_src

Email sending.
#+begin_src emacs-lisp
(use-package message
  :ensure nil ; built-in
  :config
  (setq message-send-mail-function 'message-send-mail-with-sendmail
        message-sendmail-f-is-evil t
        message-sendmail-envelope-from nil ; 'header
        message-sendmail-extra-arguments '("--read-envelope-from"))

  (setq mml-secure-smime-sign-with-sender t)
  (setq mml-secure-openpgp-sign-with-sender t)

  ;; Add signature by default
  (add-hook 'message-setup-hook 'mml-secure-message-sign-pgpmime)
  ;; Verify other's signatures
  (setq mm-verify-option 'always))

(use-package sendmail
  :ensure nil ; built-in
  :config
  (setq mail-specify-envelope-from nil
        send-mail-function 'message-send-mail-with-sendmail
        sendmail-program "msmtp"))
#+end_src
* Applications
Here go applications (almost) every normal user needs.
** GPG
#+name: nixos-section
#+begin_src nix
{
  programs.gnupg.agent = {
    enable = true;
    enableSSHSupport = true;
    pinentryFlavor = "qt";
  };

  ## is it no longer needed?
  #
  # systemd.user.sockets.gpg-agent-ssh = {
  #   wantedBy = [ "sockets.target" ];
  #   listenStreams = [ "%t/gnupg/S.gpg-agent.ssh" ];
  #   socketConfig = {
  #     FileDescriptorName = "ssh";
  #     Service = "gpg-agent.service";
  #     SocketMode = "0600";
  #     DirectoryMode = "0700";
  #   };
  # };

  services.pcscd.enable = true;
}
#+end_src

Request passwords in Emacs minibuffer. (emacs-lisp)
#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src
** Yubikey
#+name: nixos-section
#+begin_src nix
{
  environment.systemPackages = [
    pkgs.yubikey-manager
    pkgs.yubikey-personalization
    pkgs.yubikey-personalization-gui
  ];

  services.udev.packages = [
    pkgs.yubikey-personalization
    pkgs.libu2f-host
  ];
}
#+end_src
** password-store
Install [[https://www.passwordstore.org/][password-store]] along with [[https://github.com/tadfisher/pass-otp][one-time password extension]].
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    (pkgs.pass.withExtensions (exts: [ exts.pass-otp ]))
  ];
}
#+end_src

Install [[https://github.com/browserpass/browserpass][browserpass]] firefox extension backend.
#+name: home-manager-section
#+begin_src nix
{
  programs.browserpass = {
    enable = true;
    browsers = ["firefox" "chrome"];
  };
}
#+end_src

Integration with Emacs. (emacs-lisp)
#+begin_src emacs-lisp
(use-package ivy-pass
  :commands (ivy-pass))

(use-package pass
  :commands (pass))
#+end_src
** KDE apps
I don't use full KDE but some apps are definitely nice.
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    pkgs.gwenview
    pkgs.dolphin
    pkgs.kdeFrameworks.kfilemetadata
    pkgs.filelight
    pkgs.shared_mime_info
  ];
}
#+end_src

KDE apps might have issues with mime types without this:
#+name: nixos-section
#+begin_src nix
{
  environment.pathsToLink = [ "/share" ];
}
#+end_src
** Zathura
[[https://pwmt.org/projects/zathura/][Zathura]] is a cool document viewer with Vim-like bindings.
#+name: home-manager-section
#+begin_src nix
{
  programs.zathura = {
    enable = true;
    options = {
      incremental-search = true;
    };

    # Swap j/k (for Workman layout)
    extraConfig = ''
      map j scroll up
      map k scroll down
    '';
  };
}
#+end_src
** User applications
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    pkgs.google-play-music-desktop-player
    pkgs.tdesktop # Telegram

    pkgs.mplayer
    pkgs.smplayer
  ];
}
#+end_src
* Development
** Vim
Install Vim as my backup editor. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  environment.systemPackages = [
    pkgs.vim_configurable
  ];
}
#+end_src

For Home Manager–managed hosts.
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [
    pkgs.vim_configurable
  ];
}
#+end_src

Link its configuration.
#+name: home-manager-section
#+begin_src nix
{
  home.file.".vim".source = ./.vim;
  home.file.".vimrc".source = ./.vim/init.vim;
}
#+end_src
** Terminal / shell
*** rxvt-unicode
I use urxvt as my terminal emulator.
#+name: home-manager-section
#+begin_src nix
{
  programs.urxvt = {
    enable = true;
    iso14755 = false;

    fonts = [
      "-*-terminus-medium-r-normal-*-32-*-*-*-*-*-iso10646-1"
    ];

    scroll = {
      bar.enable = false;
      lines = 65535;
      scrollOnOutput = false;
      scrollOnKeystroke = true;
    };
    extraConfig = {
      "loginShell" = "true";
      "urgentOnBell" = "true";
      "secondaryScroll" = "true";

      # Molokai color theme
      "background" = "#101010";
      "foreground" = "#d0d0d0";
      "color0" = "#101010";
      "color1" = "#960050";
      "color2" = "#66aa11";
      "color3" = "#c47f2c";
      "color4" = "#30309b";
      "color5" = "#7e40a5";
      "color6" = "#3579a8";
      "color7" = "#9999aa";
      "color8" = "#303030";
      "color9" = "#ff0090";
      "color10" = "#80ff00";
      "color11" = "#ffba68";
      "color12" = "#5f5fee";
      "color13" = "#bb88dd";
      "color14" = "#4eb4fa";
      "color15" = "#d0d0d0";
    };
  };
}
#+end_src

Urxvt gets its setting from =.Xresources= file. If you ever want to reload it on-the-fly, type the following (or press =C-c C-c= if you're reading this document in emacs now):
#+begin_src sh :tangle no
xrdb ~/.Xresources
#+end_src
*** vterm
vterm is a terminal emulator using libvterm. Which allows running it within Emacs.
#+begin_src emacs-lisp
(use-package vterm
  :commands vterm
  :config
  (setq vterm-kill-buffer-on-exit t)

  (add-hook 'vterm-mode-hook #'rasen/disable-hl-line-mode)
  ;; (push 'vterm-mode evil-motion-state-modes)
  (general-def 'vterm-mode-map
    "<f1>" nil
    "<return>" nil)
  (general-def '(insert normal) 'vterm-mode-map
    "<C-return>" #'vterm-send-return
    "C-c C-z" #'evil-collection-vterm-toggle-send-escape
    "C-c z" #'evil-collection-vterm-toggle-send-escape
    )
  (general-def 'normal 'vterm-mode-map)
  (general-def 'insert 'vterm-mode-map
    "<f1>" #'vterm--self-insert
    "C-h" #'vterm--self-insert
    "<return>" #'vterm-send-return
    "C-c" nil
    "C-c C-c" #'vterm-send-C-c)

  (setq vterm-buffer-name-string "vterm %s"))
#+end_src

Fish configuration to work with vterm (~<<home-manager-section>>~):
#+name: home-manager-section
#+begin_src nix
{
  programs.fish = {

    interactiveShellInit = ''
      function vterm_prompt_end;
        vterm_printf '51;A'(whoami)'@'(hostname)':'(pwd)
      end
      functions --copy fish_prompt vterm_old_fish_prompt
      function fish_prompt --description 'Write out the prompt; do not replace this. Instead, put this at end of your file.'
        # Remove the trailing newline from the original prompt. This is done
        # using the string builtin from fish, but to make sure any escape codes
        # are correctly interpreted, use %b for printf.
        printf "%b" (string join "\n" (vterm_old_fish_prompt))
        vterm_prompt_end
      end
    '';

    functions.vterm_printf = ''
      function vterm_printf;
        if [ -n "$TMUX" ]
          # tell tmux to pass the escape sequences through
          # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
          printf "\ePtmux;\e\e]%s\007\e\\" "$argv"
        else if string match -q -- "screen*" "$TERM"
          # GNU screen (screen, screen-256color, screen-256color-bce)
          printf "\eP\e]%s\007\e\\" "$argv"
        else
          printf "\e]%s\e\\" "$argv"
        end
      end
    '';

    functions.vterm_cmd = ''
      function vterm_cmd --description 'Run an emacs command among the ones been defined in vterm-eval-cmds.'
          set -l vterm_elisp ()
          for arg in $argv
            set -a vterm_elisp (printf '"%s" ' (string replace -a -r '([\\\\"])' '\\\\\\\\$1' $arg))
          end
          vterm_printf '51;E'(string join "" $vterm_elisp)
      end
    '';

    # Use current directory as title. The title is picked up by
    # `vterm-buffer-name-string` in emacs.
    #
    # prompt_pwd is like pwd, but shortens directory name:
    # /home/rasen/dotfiles -> ~/dotfiles
    # /home/rasen/prg/project -> ~/p/project
    functions.fish_title = ''
      function fish_title
        prompt_pwd
      end
    '';
  };
}
#+end_src

Run command in vterm. Adapter from [[https://www.reddit.com/r/emacs/comments/ft84xy/run_shell_command_in_new_vterm/][r/emacs: Run shell command in vterm]]. (emacs-lisp)
#+begin_src emacs-lisp
(defun rasen/vterm-start--vterm-kill (process event)
  "A process sentinel. Kills PROCESS's buffer if it is live."
  (let ((b (process-buffer process)))
    (and (buffer-live-p b)
         (kill-buffer b))))

(defun rasen/vterm-start (command)
  "Execute string COMMAND in a new vterm.

Interactively, prompt for COMMAND with the current buffer's file
name supplied. When called from Dired, supply the name of the
file at point.

Like `async-shell-command`, but run in a vterm for full terminal features.

The new vterm buffer is named in the form `*foo bar.baz*`, the
command and its arguments in earmuffs.

When the command terminates, the shell remains open, but when the
shell exits, the buffer is killed."
  (interactive
   (list
    (let* ((f (cond (buffer-file-name)
                    ((eq major-mode 'dired-mode)
                     (dired-get-filename nil t))))
           (filename (and f (concat " " (shell-quote-argument ((file-relative-name f)))))))
      (read-shell-command "Terminal command: "
                          (cons filename 0)
                          (cons 'shell-command-history 1)
                          (and filename (list filename))))))
  (with-current-buffer (vterm (concat "*" command "*"))
    (set-process-sentinel vterm--process #'rasen/vterm-start--vterm-kill)
    (vterm-send-string command)
    (vterm-send-return)))
#+end_src
*** fish
[[https://fishshell.com/][fish]] is a cool shell, I use it as my default for day-to-day work.

#+name: nixos-section
#+begin_src nix
{
  programs.fish.enable = true;
  users.defaultUserShell = pkgs.fish;
}
#+end_src

For home-manager:
#+name: home-manager-section
#+begin_src nix
{
  programs.fish = {
    enable = true;
    shellAliases = {
      g = "git";
      rm = "rm -r";
      ec = "emacsclient";
    };
    functions = {
      # old stuff
      screencast = ''
        function screencast
            # key-mon --meta --nodecorated --theme=big-letters --key-timeout=0.05 &
            ffmpeg -probesize 3000000000 -f x11grab -framerate 25 -s 3840x3960 -i :0.0 -vcodec libx264 -threads 2 -preset ultrafast -crf 0 ~/tmp/record/record-(date +"%FT%T%:z").mkv
            # killall -r key-mon
        end
      '';
      reencode = ''
        function reencode
            ffmpeg -i file:$argv[1] -c:v libx264 -crf 0 -preset veryslow file:(basename $argv[1] .mkv).crf-0.min.mkv
        end
      '';
    };
  };

  # manage other shells as well
  programs.bash.enable = true;
}
#+end_src
**** Vi key bindings
#+name: home-manager-section
#+begin_src nix
{
  programs.fish.functions.fish_user_key_bindings = ''
    function fish_user_key_bindings
        fish_vi_key_bindings

        bind -s j up-or-search
        bind -s k down-or-search
        bind -s -M visual j up-line
        bind -s -M visual k down-line

        bind -s '.' repeat-jump
    end
  '';
}
#+end_src
*** eshell
Eshell is a shell written in Emacs lisp. It offers great integration with Emacs.
#+begin_src emacs-lisp
(use-package eshell
  :commands (eshell eshell-exec-visual)
  :init
  (defun rasen/nixos-rebuild ()
    (interactive)
    (eshell-exec-visual "sudo" "nixos-rebuild" "switch"))

  :config
  (with-eval-after-load 'em-term
    (add-to-list 'eshell-visual-commands "nethack")
    (setq eshell-destroy-buffer-when-process-dies t)))
#+end_src

#+begin_src emacs-lisp
(use-package fish-completion
  :when (executable-find "fish")
  :config
  (global-fish-completion-mode))
#+end_src
*** tmux
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  environment.systemPackages = [ pkgs.tmux ];
}
#+end_src

For home-manager. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.tmux = {
    enable = true;
    keyMode = "vi";
    # Use C-a as prefix
    shortcut = "a";
    # To make vim work properly
    terminal = "screen-256color";

    # start numbering from 1
    baseIndex = 1;
    # Allows for faster key repetition
    escapeTime = 0;
    historyLimit = 10000;

    reverseSplit = true;

    clock24 = true;

    extraConfig = ''
      bind-key S-left swap-window -t -1
      bind-key S-right swap-window -t +1

      bind h select-pane -L
      bind k select-pane -D
      bind j select-pane -U
      bind l select-pane -R

      bind r source-file ~/.tmux.conf \; display-message "Config reloaded..."

      set-window-option -g automatic-rename
    '';
  };
}
#+end_src
*** Other terminal goodies
#+name: nixos-section
#+begin_src nix
{
  environment.systemPackages = [
    pkgs.wget
    pkgs.htop
    pkgs.psmisc
    pkgs.zip
    pkgs.unzip
    pkgs.unrar
    pkgs.bind
    pkgs.file
    pkgs.which
    # pkgs.utillinuxCurses
    pkgs.ripgrep
    pkgs.xclip

    pkgs.patchelf

    pkgs.python3
  ];
  # environment.variables.NPM_CONFIG_PREFIX = "$HOME/.npm-global";
  # environment.variables.PATH = "$HOME/.npm-global/bin:$PATH";
}
#+end_src
** git
*** git config
(~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.git = {
    enable = true;
    package = pkgs.gitAndTools.gitFull;

    userName = "Alexey Shmalko";
    userEmail = "rasen.dubi@gmail.com";

    signing = {
      key = "EB3066C3";
      signByDefault = true;
    };

    extraConfig = {
      sendemail = {
        smtpencryption = "ssl";
        smtpserver = "smtp.gmail.com";
        smtpuser = "rasen.dubi@gmail.com";
        smtpserverport = 465;
      };

      color.ui = true;
      core.editor = "vim";
      push.default = "simple";
      pull.rebase = true;
      rebase.autostash = true;
      rerere.enabled = true;
      advice.detachedHead = false;
    };
  };
}
#+end_src

I have *LOTS* of aliases (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.git.aliases = {
    cl    = "clone";
    gh-cl = "gh-clone";
    cr    = "cr-fix";
    p     = "push";
    pl    = "pull";
    f     = "fetch";
    fa    = "fetch --all";
    a     = "add";
    ap    = "add -p";
    d     = "diff";
    dl    = "diff HEAD~ HEAD";
    ds    = "diff --staged";
    l     = "log --show-signature";
    l1    = "log -1";
    lp    = "log -p";
    c     = "commit";
    ca    = "commit --amend";
    co    = "checkout";
    cb    = "checkout -b";
    cm    = "checkout origin/master";
    de    = "checkout --detach";
    fco   = "fetch-checkout";
    br    = "branch";
    s     = "status";
    re    = "reset --hard";
    r     = "rebase";
    rc    = "rebase --continue";
    ri    = "rebase -i";
    m     = "merge";
    t     = "tag";
    su    = "submodule update --init --recursive";
    bi    = "bisect";
  };
}
#+end_src

Always push to github with ssh keys instead of login/password. (~<<home-manager-section>>~)
#+name: home-manager-section
#+begin_src nix
{
  programs.git.extraConfig = {
    url."git@github.com:".pushInsteadOf = "https://github.com";
  };
}
#+end_src

Also, install git for the rest of the system. (~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  environment.systemPackages = [ pkgs.git ];
}
#+end_src

git-config mode for emacs.
#+begin_src emacs-lisp
(use-package gitconfig-mode
  :mode "^\\.gitconfig$")
#+end_src
*** magit
Magit is a cool emacs interface to git. (emacs-lisp)
#+begin_src emacs-lisp
(use-package magit
  :general
  (:states 'motion
   "g m"    #'magit-status)
  :diminish auto-revert-mode
  :config
  <<magit-config>>
  )
#+end_src

Do not put files into trash can. Delete them for real. (~<<magit-config>>~)
#+name: magit-config
#+begin_src emacs-lisp
(setq-default magit-delete-by-moving-to-trash nil)
#+end_src

Integrate with ivy. (~<<magit-config>>~)
#+name: magit-config
#+begin_src emacs-lisp
(setq-default magit-completing-read-function 'ivy-completing-read)
#+end_src

Use =q= to quit transient buffers.
#+begin_src emacs-lisp
(use-package transient
  :defer t
  :config
  (transient-bind-q-to-quit))
#+end_src
**** Evil
Evilify magit-mode. (emacs-lisp)
#+begin_src emacs-lisp
(use-package evil-magit
  :config
  <<evil-magit-config>>
  )
#+end_src

(emacs-lisp)
#+begin_src emacs-lisp
(setq evil-magit-use-y-for-yank t)
#+end_src

Evilify magit-blame. (~<<evil-magit-config>>~)
#+name: evil-magit-config
#+begin_src emacs-lisp
(general-def 'normal magit-blame-read-only-mode-map
  "k"    #'evil-next-visual-line
  "j"    #'evil-previous-visual-line
  "C-k"  #'magit-blame-next-chunk
  "C-j"  #'magit-blame-previous-chunk
  "gk"   #'magit-blame-next-chunk-same-commit
  "gj"   #'magit-blame-previous-chunk-same-commit)

(general-def magit-blame-read-only-mode-map "SPC" nil) ;; expose my leader

(general-def
  :states `(,evil-magit-state visual)
  :keymaps 'magit-mode-map
  "j"    #'evil-previous-visual-line
  "k"    #'evil-next-visual-line
  "C-j"  #'magit-section-backward
  "C-k"  #'magit-section-forward
  "gj"   #'magit-section-backward-sibling
  "gk"   #'magit-section-forward-sibling)
#+end_src
**** Custom commands
***** git push HEAD ...
Add a magit command to push =HEAD= into a specified ref. Bound to ~p h~.
#+name: magit-config
#+begin_src emacs-lisp
(defun rasen/magit-push-head (target args)
  "Push HEAD to a branch read in the minibuffer."
  (interactive
   (list (magit-read-remote-branch "Push HEAD to"
                                   nil nil nil 'confirm)
         (magit-push-arguments)))
  (magit-git-push "HEAD" target args))

(if (fboundp 'transient-insert-suffix)
    (transient-insert-suffix 'magit-push 'magit-push-other
      '(1 "h" "HEAD" rasen/magit-push-head))
  (magit-define-popup-action 'magit-push-popup
                             ?h "HEAD" 'rasen/magit-push-head))
#+end_src

***** git fetch origin/master && git checkout origin/master
(evil-magit)
#+name: evil-magit-config
#+begin_src emacs-lisp
(defun rasen/magit-fco (remote refspec args)
  "Fetch remote branch and checkout it (detached HEAD)."
  (interactive
   (let ((remote (magit-read-remote-or-url "Fetch from remote or url")))
     (list remote
           (magit-read-refspec "Fetch using refspec" remote)
           (magit-fetch-arguments))))
  (magit-git-fetch remote (cons refspec args))
  ;; FIXME: magit-checkout does not wait for git fetch to finish.
  (magit-checkout "FETCH_HEAD"))

(if (fboundp 'transient-insert-suffix)
    (transient-insert-suffix 'magit-fetch 'magit-fetch-modules
      '(1 "c" "checkout" rasen/magit-fco)))

(defun rasen/magit-fco-master ()
  "Fetch origin/master and checkout it."
  (interactive)
  (magit-git-fetch "origin" "master")
  (magit-checkout "origin/master"))

(evil-magit-define-key evil-magit-state 'magit-mode-map
                       "g m" 'rasen/magit-fco-master)
#+end_src
***** TODO add a detach head command (git checkout HEAD)
**** GPG
Sign commits by default. (~<<magit-config>>~)
#+name: magit-config
#+begin_src emacs-lisp
(setq magit-commit-arguments '("--gpg-sign=DCEF7BCCEB3066C3"))
#+end_src

Show commit signatures in log. (~<<magit-config>>~)
#+name: magit-config
#+begin_src emacs-lisp
(setq magit-log-arguments '("--graph" "--decorate" "--show-signature" "-n256"))
#+end_src
*** git-commit
git-commit is emacs mode for editing commit messages. (emacs-lisp)
#+begin_src emacs-lisp
(use-package git-commit
  :gfhook 'flyspell-mode

  :general
  (:keymaps 'with-editor-mode-map
   :states 'normal
   "'" #'with-editor-finish)

  :config
  (add-to-list 'evil-insert-state-modes 'with-editor-mode)
  (setq evil-normal-state-modes (delete 'git-commit-mode evil-normal-state-modes)))
#+end_src
*** diff-hl
[[https://github.com/dgutov/diff-hl][diff-hl]] is an emacs package to highlight uncommitted changes.
#+begin_src emacs-lisp
(use-package diff-hl
  :after magit
  :config
  (require 'diff-hl-flydiff)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  (diff-hl-flydiff-mode t)
  (global-diff-hl-mode t))
#+end_src
** Man pages
This install a number of default man pages for the linux/posix system.
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  documentation = {
    man.enable = true;
    dev.enable = true;
  };

  environment.systemPackages = [
    pkgs.man-pages
    pkgs.stdman
    pkgs.posix_man_pages
    pkgs.stdmanpages
  ];
}
#+end_src
** Emacs
*** Use spaces for indentation
Do not use tabs for indentation.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src
*** Make underscore part of words
Make '_' a part of words so that commands like =evil-forward-word-begin= work properly.
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook
          (lambda () (modify-syntax-entry ?_ "w")))
#+end_src
*** Color compilation mode
#+begin_src emacs-lisp
(require 'ansi-color)
(add-hook 'compilation-filter-hook
          (defun rasen/colorize-compilation-buffer ()
            (when (eq major-mode 'compilation-mode)
              (ansi-color-apply-on-region compilation-filter-start (point-max)))))
#+end_src
*** projectile
#+begin_src emacs-lisp
(use-package projectile
  :general
  (s-leader-def
    "p" #'projectile-command-map)
  ('motion
   ;; That works much better than the default
   "g f"    #'projectile-find-file-dwim
   "U"      #'projectile-find-file
   "<f3>"   #'projectile-test-project
   "<f4>"   #'projectile-compile-project
   "<f5>"   #'projectile-run-project)
  :commands (projectile-project-name)
  :diminish projectile-mode
  :config
  ;; Use the prefix arg if you want to change the compilation command
  (setq-default compilation-read-command nil)

  (setq-default projectile-use-git-grep t)

  ;; projectile-find-file is slow on very large projects.  Enable
  ;; known-files caching for projectile to speed it up.
  ;; (Note: clear cache with `projectile-invalidate-cache', or C-u U)
  ;; (setq-default projectile-enable-caching t)
  ;; set projectile-enable-caching on a per-project basis in .dir-locals.el

  (setq-default projectile-completion-system 'ivy)
  (projectile-mode))
#+end_src

#+begin_src emacs-lisp
(use-package counsel-projectile
  :after projectile
  :config
  (counsel-projectile-mode))
#+end_src
*** company
Company mode provides autocomplete features.
#+begin_src emacs-lisp
(use-package company
  :defer 2
  :general
  (:keymaps 'company-mode-map
   :states 'insert
   "C-n" #'company-complete-common-or-cycle
   "C-p" #'company-select-previous)
  ('company-active-map
   "C-n" #'company-complete-common-or-cycle
   "C-p" #'company-select-previous-or-abort
   "C-e" #'company-complete
   "TAB" #'company-complete-common-or-cycle)

  :diminish company-mode
  :config
  (setq-default company-dabbrev-downcase nil)
  (setq-default company-search-filtering t)
  (global-company-mode))
#+end_src

Company-box frontend works better with variable-pitch fonts.
#+begin_src emacs-lisp
(use-package company-box
  :diminish
  :hook (company-mode . company-box-mode))
#+end_src
*** Hippie expand
Useful for languages that do not support proper completion.
#+begin_src emacs-lisp
(use-package hippie-exp
  :general
  ('insert
   "C-/"  #'hippie-expand)
  :config
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev-visible
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-line
          try-expand-list)))
#+end_src
*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :config
  ;; not sure I actually use nix-sandbox
  ;; (setq flycheck-command-wrapper-function
  ;;       (lambda (cmd) (apply 'nix-shell-command (nix-current-sandbox) cmd))

  ;;       flycheck-executable-find
  ;;       (lambda (cmd) (nix-executable-find (nix-current-sandbox) cmd)))

  ;; Do not check for elisp header/footer
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(emacs-lisp-checkdoc)))

  (global-flycheck-mode))
#+end_src
*** flycheck-inline
Display flycheck error inline.
#+begin_src emacs-lisp
(use-package flycheck-inline
  :after flycheck
  :config
  (global-flycheck-inline-mode))
#+end_src
*** electric-pair
Auto-close pairs.
#+begin_src emacs-lisp
(electric-pair-mode)
#+end_src
*** Color identifiers
#+begin_src emacs-lisp
(use-package color-identifiers-mode
  :commands (color-identifiers-mode
             global-color-identifiers-mode)
  :diminish (color-identifiers-mode
             global-color-identifiers-mode))
#+end_src
*** dtrt-indent
Automatically determine indent style.
#+begin_src emacs-lisp
(use-package dtrt-indent
  :diminish
  :config
  (dtrt-indent-global-mode))
#+end_src
*** paren-face
Dim parens.
#+begin_src emacs-lisp
(use-package paren-face
  :config
  (global-paren-face-mode))
#+end_src
*** LSP
LSP is Language Server Protocol. Some languages support it usually provide better completion and diagnostics.
#+begin_src emacs-lisp
(use-package lsp-mode
  :disabled t
  :commands (lsp)
  :hook ((rust-mode haskell-mode) . lsp)
  :config
  (setq lsp-prefer-flymake nil)
  (setq lsp-rust-rls-server-command "rls")
  (setq lsp-rust-analyzer-server-command "rust-analyzer"))

(use-package lsp-ui
  :disabled t
  :commands lsp-ui-mode)

(use-package company-lsp
  :disabled t
  :commands company-lsp)

(use-package eglot
  :hook ((rust-mode) . eglot-ensure))
#+end_src
*** Commenting
#+begin_src emacs-lisp
(leader-def '(normal visual)  "/" #'comment-line)
#+end_src
*** yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :defer 5
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)

  (setq rasen/snippets-directory
        (file-name-as-directory
         (expand-file-name ".emacs.d/snippets" rasen/dotfiles-directory)))

  (make-directory rasen/snippets-directory t)
  (yas-load-directory rasen/snippets-directory)

  ;; yasnippet's wrapping doesn't work well with evil. When you
  ;; trigger a snippet from a visual state, it switches into normal
  ;; state, but cursor moves in such a way, so that you leave the
  ;; snippet, so you're not able to supply other fields ($1, $2,
  ;; etc.).
  ;;
  ;; This function installed as `yas-before-expand-snippet-hook'
  ;; switches into insert state before expanding the snippet, so you
  ;; can supply all the fields.
  ;;
  ;; Note that it is not always desirable because some snippets don't
  ;; have extra fields, so switching to insert state has not sense.
  ;; In order for the switch to kick in, set `rasen/evil-state'
  ;; expand-env to "insert" like this:
  ;;
  ;; # expand-env: ((rasen/evil-state "insert"))
  (defun rasen/yas-before-expand-snippet ()
    (when (not (string-or-null-p snippet))
      (let ((state (car (alist-get 'rasen/evil-state (yas--template-expand-env snippet)))))
        (when (and (equal state "insert") (evil-visual-state-p))
          (let ((beg evil-visual-beginning)
                (end evil-visual-end))
            (evil-insert-state nil)
            ;; restore mark and point
            (if (eq (char-after beg) ?\s)
                ;; skip whitespaces, if present
                (progn
                  (goto-char beg)
                  (forward-whitespace 1)
                  (set-mark (point)))
              (set-mark beg))
            (goto-char end)
            (when (bolp)
              (backward-char)))))))

  (add-hook 'yas-before-expand-snippet-hook #'rasen/yas-before-expand-snippet)

  (add-hook 'term-mode-hook (lambda ()
                              (setq-local yas-dont-activate-functions t))))
#+end_src
** Languages
*** Emacs lisp
#+begin_src emacs-lisp
(use-package elisp-mode
  :ensure nil ; built-in
  :config
  <<elisp-mode-config>>
  )
#+end_src

Eval last sexp Vim-style.
#+name: elisp-mode-config
#+begin_src emacs-lisp
(evil-define-operator rasen/evil-eval (beg end type)
  "Evaluate region."
  (if (eq type 'block)
      (evil-apply-on-block 'eval-region beg end nil)
    (eval-region beg end)))

(general-def 'motion emacs-lisp-mode-map "SPC e" #'eval-last-sexp)
(general-def 'visual emacs-lisp-mode-map "SPC e" #'rasen/evil-eval)
#+end_src
**** aggressive indent
Keep lisp code always indented.
#+begin_src emacs-lisp
(use-package aggressive-indent
  :commands (aggressive-indent-mode aggressive-indent-global-mode)
  :hook
  (clojure-mode . aggressive-indent-mode)
  (clojurescript-mode . aggressive-indent-mode)
  (emacs-lisp-mode . aggressive-indent-mode))
#+end_src
**** Fix indentation for keywords
Alternate indent function definition.
#+begin_src emacs-lisp
;; Fix the indentation of keyword lists in Emacs Lisp. See [1] and [2].
;;
;; Before:
;;  (:foo bar
;;        :baz quux)
;;
;; After:
;;  (:foo bar
;;   :bar quux)
;;
;; [1]: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94
;; [2]: http://emacs.stackexchange.com/q/10230/12534
(el-patch-defun (el-patch-swap lisp-indent-function rasen/emacs-lisp-indent-function) (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

,* `defun', meaning indent `defun'-style
  (this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (el-patch-let (($cond (and (elt state 2)
                             (el-patch-wrap 1 1
                               (or (not (looking-at "\\sw\\|\\s_"))
                                   (looking-at ":")))))
                 ($then (progn
                          (if (not (> (save-excursion (forward-line 1) (point))
                                      calculate-lisp-indent-last-sexp))
                              (progn (goto-char calculate-lisp-indent-last-sexp)
                                     (beginning-of-line)
                                     (parse-partial-sexp (point)
                                                         calculate-lisp-indent-last-sexp 0 t)))
                          ;; Indent under the list or under the first sexp on the same
                          ;; line as calculate-lisp-indent-last-sexp.  Note that first
                          ;; thing on that line has to be complete sexp since we are
                          ;; inside the innermost containing sexp.
                          (backward-prefix-chars)
                          (current-column)))
                 ($else (let ((function (buffer-substring (point)
                                                          (progn (forward-sexp 1) (point))))
                              method)
                          (setq method (or (function-get (intern-soft function)
                                                         'lisp-indent-function)
                                           (get (intern-soft function) 'lisp-indent-hook)))
                          (cond ((or (eq method 'defun)
                                     (and (null method)
                                          (> (length function) 3)
                                          (string-match "\\`def" function)))
                                 (lisp-indent-defform state indent-point))
                                 ((integerp method)
                                 (lisp-indent-specform method state
                                                       indent-point normal-indent))
                                (method
                                 (funcall method indent-point state))))))
    (let ((normal-indent (current-column))
          (el-patch-add
            (orig-point (point))))
      (goto-char (1+ (elt state 1)))
      (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
      (el-patch-swap
        (if $cond
            ;; car of form doesn't seem to be a symbol
            $then
          $else)
        (cond
         ;; car of form doesn't seem to be a symbol, or is a keyword
         ($cond $then)
         ((and (save-excursion
                 (goto-char indent-point)
                 (skip-syntax-forward " ")
                 (not (looking-at ":")))
               (save-excursion
                 (goto-char orig-point)
                 (looking-at ":")))
          (save-excursion
            (goto-char (+ 2 (elt state 1)))
            (current-column)))
         (t $else))))))
#+end_src
Apply it for emacs-lisp-mode.
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'rasen/emacs-lisp-indent-function)))
#+end_src
*** Nix
Pretty self-explaining.
#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix$")
#+end_src
*** Haskell
(Old un-reviewed stuff.)
#+begin_src emacs-lisp
(use-package haskell-mode
  :mode "\\.hs$"
  :init
  (setq company-ghc-show-info t)
  (setq flycheck-ghc-stack-use-nix t)
  :config
  (add-hook 'haskell-mode-hook #'interactive-haskell-mode)
  (add-hook 'haskell-mode-hook #'haskell-decl-scan-mode)
  (add-hook 'haskell-mode-hook #'lsp)

  (setq haskell-compile-cabal-build-command "cd %s && stack build")
  (setq haskell-compile-cabal-build-command-alt "cd %s && cabal build --ghc-options=-ferror-spans")

  ;; Use Nix for stack ghci
  (add-to-list 'haskell-process-args-stack-ghci "--fast --nix")
  (add-to-list 'haskell-process-args-stack-ghci "--test")

  ;; Use Nix for default build/test command
  (projectile-register-project-type 'haskell-stack
                                    '("stack.yaml")
                                    :compile "stack build --fast --nix"
                                    :test "stack build --nix --test")

  (general-def haskell-mode-map
    [f8]       #'haskell-navigate-imports
    "C-c C-b"  #'haskell-compile
    "C-c v c"  #'haskell-cabal-visit-file

    ;; haskell-interactive-mode
    "C-x C-d"  nil
    "C-c C-z"  #'haskell-interactive-switch
    "C-c C-l"  #'haskell-process-load-file
    "C-c C-t"  #'haskell-process-do-type
    "C-c C-i"  #'haskell-process-do-info
    "C-c M-."  nil
    "C-c C-d"  nil)

  ;; Disable popups (i.e., report errors in the interactive shell).
  (setq haskell-interactive-popup-errors nil)

  (setq haskell-process-suggest-remove-import-lines t
        haskell-process-auto-import-loaded-modules t)

  (with-eval-after-load 'align
    (add-to-list 'align-rules-list
                 '(haskell-types
                   (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                   (modes . '(haskell-mode literate-haskell-mode))))
    (add-to-list 'align-rules-list
                 '(haskell-assignment
                   (regexp . "\\(\\s-+\\)=\\s-+")
                   (modes . '(haskell-mode literate-haskell-mode))))
    (add-to-list 'align-rules-list
                 '(haskell-arrows
                   (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                   (modes . '(haskell-mode literate-haskell-mode))))
    (add-to-list 'align-rules-list
                 '(haskell-left-arrows
                   (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                   (modes . '(haskell-mode literate-haskell-mode))))))
#+end_src

#+begin_src emacs-lisp
(use-package lsp-haskell
  :after haskell-mode lsp-mode)
#+end_src
*** Rust
#+begin_src emacs-lisp
(use-package eldoc
  :commands (eldoc-mode)
  :diminish eldoc-mode)

(use-package rust-mode
  :mode ("\\.rs$" . rust-mode)
  :config
  (add-hook 'rust-mode-hook (lambda () (setq-local fill-column 100))))

(use-package racer
  :after rust-mode
  :commands racer-mode
  :diminish racer-mode
  :config
  (setq racer-rust-src-path nil) ; Nix manages that
  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode))

(use-package flycheck-rust
  :after rust-mode
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+end_src
*** Go
#+begin_src emacs-lisp
(use-package go-mode
  :mode ("\\.go$" . go-mode))
#+end_src
*** C/C++
**** Doxygen
This const is taken from doxymacs and is subject to GPLv2. I've copied it my dotfiles as I don't need all doxymacs features and setup is non-trivial. (It requires compilation, there is no melpa package.)
#+begin_src emacs-lisp
(defconst doxymacs-doxygen-keywords
  (list
   (list
    ;; One shot keywords that take no arguments
    (concat "\\([@\\\\]\\(brief\\|li\\|\\(end\\)?code\\|sa"
            "\\|note\\|\\(end\\)?verbatim\\|return\\|arg\\|fn"
            "\\|hideinitializer\\|showinitializer"
            "\\|parblock\\|endparblock"
            ;; FIXME
            ;; How do I get & # < > % to work?
            ;;"\\|\\\\&\\|\\$\\|\\#\\|<\\|>\\|\\%"
            "\\|internal\\|nosubgrouping\\|author\\|date\\|endif"
            "\\|invariant\\|post\\|pre\\|remarks\\|since\\|test\\|version"
            "\\|\\(end\\)?htmlonly\\|\\(end\\)?latexonly\\|f\\$\\|file"
            "\\|\\(end\\)?xmlonly\\|\\(end\\)?manonly\\|property"
            "\\|mainpage\\|name\\|overload\\|typedef\\|deprecated\\|par"
            "\\|addindex\\|line\\|skip\\|skipline\\|until\\|see"
            "\\|endlink\\|callgraph\\|endcond\\|else\\)\\)\\>")
    '(0 font-lock-keyword-face prepend))
   ;; attention, warning, etc. given a different font
   (list
    "\\([@\\\\]\\(attention\\|warning\\|todo\\|bug\\)\\)\\>"
    '(0 font-lock-warning-face prepend))
   ;; keywords that take a variable name as an argument
   (list
    (concat "\\([@\\\\]\\(param\\(?:\\s-*\\[\\(?:in\\|out\\|in,out\\)\\]\\)?"
            "\\|a\\|namespace\\|relates\\(also\\)?"
            "\\|var\\|def\\)\\)\\s-+\\(\\sw+\\)")
    '(1 font-lock-keyword-face prepend)
    '(4 font-lock-variable-name-face prepend))
   ;; keywords that take a type name as an argument
   (list
    (concat "\\([@\\\\]\\(class\\|struct\\|union\\|exception\\|enum"
            "\\|throw\\|interface\\|protocol\\)\\)\\s-+\\(\\(\\sw\\|:\\)+\\)")
    '(1 font-lock-keyword-face prepend)
    '(3 font-lock-type-face prepend))
   ;; keywords that take a function name as an argument
   (list
    "\\([@\\\\]retval\\)\\s-+\\([^ \t\n]+\\)"
    '(1 font-lock-keyword-face prepend)
    '(2 font-lock-function-name-face prepend))
   ;; bold
   (list
    "\\([@\\\\]b\\)\\s-+\\([^ \t\n]+\\)"
    '(1 font-lock-keyword-face prepend)
    '(2 (quote bold) prepend))
   ;; code
   (list
    "\\([@\\\\][cp]\\)\\s-+\\([^ \t\n]+\\)"
    '(1 font-lock-keyword-face prepend)
    '(2 (quote underline) prepend))
   ;; italics/emphasised
   (list
    "\\([@\\\\]e\\(m\\)?\\)\\s-+\\([^ \t\n]+\\)"
    '(1 font-lock-keyword-face prepend)
    '(3 (quote italic) prepend))
   ;; keywords that take a list
   (list
    "\\([@\\\\]ingroup\\)\\s-+\\(\\(\\sw+\\s-*\\)+\\)\\s-*$"
    '(1 font-lock-keyword-face prepend)
    '(2 font-lock-string-face prepend))
   ;; one argument that can contain arbitrary non-whitespace stuff
   (list
    (concat "\\([@\\\\]\\(link\\|copydoc\\|xrefitem"
            "\\|if\\(not\\)?\\|elseif\\)\\)"
            "\\s-+\\([^ \t\n]+\\)")
    '(1 font-lock-keyword-face prepend)
    '(4 font-lock-string-face prepend))
   ;; one optional argument that can contain arbitrary non-whitespace stuff
   (list
    "\\([@\\\\]\\(cond\\|dir\\)\\(\\s-+[^ \t\n]+\\)?\\)"
    '(1 font-lock-keyword-face prepend)
    '(3 font-lock-string-face prepend t))
   ;; one optional argument with no space between
   (list
    "\\([@\\\\]\\(~\\)\\([^ \t\n]+\\)?\\)"
    '(1 font-lock-keyword-face prepend)
    '(3 font-lock-string-face prepend t))
   ;; one argument that has to be a filename
   (list
    (concat "\\([@\\\\]\\(example\\|\\(dont\\)?include\\|includelineno"
            "\\|htmlinclude\\|verbinclude\\)\\)\\s-+"
            "\\(\"?[~:\\/a-zA-Z0-9_. ]+\"?\\)")
    '(1 font-lock-keyword-face prepend)
    '(4 font-lock-string-face prepend))
   ;; dotfile <file> ["caption"]
   (list
    (concat "\\([@\\\\]dotfile\\)\\s-+"
            "\\(\"?[~:\\/a-zA-Z0-9_. ]+\"?\\)\\(\\s-+\"[^\"]+\"\\)?")
    '(1 font-lock-keyword-face prepend)
    '(2 font-lock-string-face prepend)
    '(3 font-lock-string-face prepend t))
   ;; image <format> <file> ["caption"] [<sizeindication>=<size>]
   (list
    "\\([@\\\\]image\\)\\s-+\\(html\\|latex\\)\\s-+\\(\"?[~:\\/a-zA-Z0-9_. ]+\"?\\)\\(\\s-+\"[^\"]+\"\\)?\\(\\s-+\\sw+=[0-9]+\\sw+\\)?"
    '(1 font-lock-keyword-face prepend)
    '(2 font-lock-string-face prepend)
    '(3 font-lock-string-face prepend)
    '(4 font-lock-string-face prepend t)
    '(5 font-lock-string-face prepend t))
   ;; one argument that has to be a word
   (list
    (concat "\\([@\\\\]\\(addtogroup\\|defgroup\\|weakgroup"
            "\\|page\\|anchor\\|ref\\|section\\|subsection\\|subsubsection\\|paragraph"
            "\\)\\)\\s-+\\(\\sw+\\)")
    '(1 font-lock-keyword-face prepend)
    '(3 font-lock-string-face prepend))))

(defconst doxygen-font-lock-keywords
  `((,(lambda (limit)
        (c-font-lock-doc-comments "/\\(\\*[\\*!]\\|/[/!]\\)<?" limit
          doxymacs-doxygen-keywords)))))

(setq c-doc-comment-style '((java-mode . javadoc)
                            (pike-mode . autodoc)
                            (c-mode . doxygen)
                            (c++-mode . doxygen)))
#+end_src
*** CMake
#+begin_src emacs-lisp
(use-package cmake-mode
  :mode
  (("CMakeLists\\.txt\\'" . cmake-mode)
   ("\\.cmake\\'"         . cmake-mode)))
#+end_src
*** Python
#+begin_src emacs-lisp
(use-package elpy
  :after (flycheck)
  :config
  ;; Do not show vertical guides in python code
  (setq elpy-modules (delq 'elpy-module-highlight-indentation elpy-modules))

  ;; Do not use flymake (flycheck will kick in instead)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))

  ;; Use python3 (instead of python2)
  (setq flycheck-python-flake8-executable "python3"
        flycheck-python-pycompile-executable "python3"
        flycheck-python-pylint-executable "python3")

  (elpy-enable))
#+end_src

#+begin_src emacs-lisp
(use-package blacken
  :hook (elpy-mode . blacken-mode))
#+end_src

#+begin_src emacs-lisp
(use-package py-autopep8
  :hook (elpy-mode . py-autopep8-enable-on-save)
  :config
  (defun rasen/autopep8-disable-on-save ()
    (interactive)
    (remove-hook 'before-save-hook 'py-autopep8-buffer t)))
#+end_src

#+begin_src emacs-lisp
(use-package pip-requirements
  :mode "^requirements.txt$")
#+end_src
*** JavaScript
#+begin_src emacs-lisp
(use-package js2-mode
  :mode "\\.js$"
  :init
  (add-hook 'js2-mode-hook 'color-identifiers-mode)
  :config

  (defun rasen/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'rasen/use-eslint-from-node-modules)

  (add-hook 'js2-mode-hook
            (lambda ()
              (flycheck-select-checker 'javascript-eslint)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (setq-default flycheck-enabled-checkers
                (append flycheck-enabled-checkers
                        '(javascript-eslint)))

  (flycheck-add-mode 'javascript-eslint 'js2-mode)

  (setq-default js2-strict-trailing-comma-warning nil))

(use-package rjsx-mode
  :mode "\\.js$"
  :config
  (setq-default js-indent-level 2))
#+end_src
*** Typescript
#+begin_src emacs-lisp
(use-package typescript-mode
  :commands (typescript-mode)
  :gfhook
  #'rasen/setup-tide-mode
  :init
  (el-patch-feature typescript-mode)
  (add-hook 'web-mode-hook
            (lambda ()
              (when (or (string-equal "tsx" (file-name-extension buffer-file-name))
                        (string-equal "ts" (file-name-extension buffer-file-name)))
                (typescript-mode))))
  :general
  ('insert
   'typescript-mode-map
   "M-j"   #'c-indent-new-comment-line
   "C-M-j" #'c-indent-new-comment-line)
  :config
  (setq-default typescript-indent-level 2)

  ;; Add more jsdoc tags
  (el-patch-defconst typescript-jsdoc-empty-tag-regexp
    (concat typescript-jsdoc-before-tag-regexp
            "\\(@"
            (regexp-opt
             '("abstract"
               "addon"
               "async"
               "author"
               "class"
               "classdesc"
               "const"
               "constant"
               "constructor"
               "constructs"
               "copyright"
               "default"
               "defaultvalue"
               "deprecated"
               "desc"
               "description"
               "event"
               "example"
               "exec"
               "export"
               "exports"
               "file"
               "fileoverview"
               "final"
               "func"
               "function"
               "generator"
               "global"
               "hidden"
               "hideconstructor"
               "ignore"
               "implicitcast"
               "inheritdoc"
               "inner"
               "instance"
               "interface"
               "license"
               "method"
               "mixin"
               "noalias"
               "noshadow"
               "notypecheck"
               "override"
               "overview"
               "owner"
               "package"
               "preserve"
               "preservetry"
               "private"
               "protected"
               "public"
               "readonly"
               "static"
               "summary"
               "supported"
               "todo"
               "tutorial"
               "virtual"
               (el-patch-add
                 "remarks"
                 "alpha"
                 "beta"
                 "defaultValue"
                 "eventProperty"
                 "example"
                 "experimental"
                 "inheritDoc"
                 "internal"
                 "label"
                 "link"
                 "packageDocumentation"
                 "privateRemarks"
                 "sealed"
                 "typeParam")))
            "\\)\\s-*")
    "Matches empty jsdoc tags."))
#+end_src

#+begin_src emacs-lisp
(use-package tide
  :commands (tide-setup
             tide-hl-identifier-mode
             tide-format-before-save)
  :hook
  (typescript-mode . rasen/setup-tide-mode)
  :init
  (defun rasen/setup-tide-mode ()
    (interactive)
    (with-demoted-errors "tide-setup: %S"
      (tide-setup))
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1))
  :config
  ;; K is used for avy
  (general-def 'normal 'tide-mode-map
    "K" nil))
#+end_src

#+begin_src emacs-lisp
(use-package prettier-js
  :commands (prettier-js prettier-js-mode)
  :hook
  (typescript-mode . prettier-js-mode))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck-jest
  :after flycheck)
#+end_src
*** Vue
#+begin_src emacs-lisp
(use-package vue-mode
  :mode "\\.vue$")
#+end_src
*** Web-mode
#+begin_src emacs-lisp
(use-package web-mode
  :commands (web-mode)
  :init
  (add-to-list 'auto-mode-alist '("\\.blade.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
  :config
  (setq web-mode-engines-alist
        '(("php"    . "\\.phtml\\'")
          ("blade"  . "\\.blade\\."))))
#+end_src
*** Clojure(Script)
#+begin_src emacs-lisp
(use-package clojure-mode
  :mode "\\.\\(clj\\|cljs\\)$")

(use-package cider
  :after clojure-mode
  :config
  (evil-set-initial-state 'cider-stacktrace-mode 'emacs))
#+end_src
*** Racket
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.racket ];
}
#+end_src

#+begin_src emacs-lisp
(use-package racket-mode
  :mode "\\.rkt$"
  :gfhook
  #'lispyville-mode
  #'aggressive-indent-mode
  #'paren-face-mode
  :general
  ('motion
   'racket-mode-map
   "g h" #'racket-repl-describe
   "SPC e" #'rasen/racket-evil-send-last-sexp)
  ('racket-repl-mode-map
   "C-j" nil)
  ('insert
   'racket-repl-mode-map
   "C-j" #'newline-and-indent)
  :config
  (evil-set-initial-state 'racket-describe-mode 'motion)

  (defun rasen/racket-evil-send-last-sexp ()
    (interactive)
    (save-excursion
      (right-char)
      (racket-send-last-sexp))))
#+end_src
*** Groovy
#+begin_src emacs-lisp
(use-package groovy-mode
  :mode "\\.\\(groovy\\|gradle\\)$")
#+end_src
*** Kotlin
#+begin_src emacs-lisp
(use-package kotlin-mode
  :mode "\\.kt'")
#+end_src
*** Forth
#+begin_src emacs-lisp
(use-package forth-mode
  :config
  (defun rasen/disable-electric-pair ()
    (interactive)
    (electric-pair-local-mode -1))
  (add-hook 'forth-mode-hook #'rasen/disable-electric-pair))
#+end_src
*** Lua
#+begin_src emacs-lisp
(use-package lua-mode
  :mode ("\\.lua$" . lua-mode)
  :config
  (setq lua-indent-level 4))
#+end_src
*** Ledger / Hledger
#+begin_src emacs-lisp
(use-package ledger-mode
  :mode "\\.journal$"
  :config
  (setq ledger-binary-path "hledger")
  (add-hook 'ledger-mode-hook 'orgstruct-mode))
#+end_src
*** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("\\.\\(markdown\\|mdown\\|md\\)$" . markdown-mode)
  :commands gfm-view-mode
  :init
  (add-hook 'markdown-mode-hook 'visual-line-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  :config
  (defun rasen/insert-timestamp ()
    "Insert current timestamp in ISO 8601 format"
    (interactive)
    (insert (format-time-string "%FT%R%z")))

  (general-def 'normal markdown-mode-map
    "'"      #'markdown-edit-code-block
    "C-c '"  (rasen/hard-way "'"))
  (general-def 'normal edit-indirect-mode-map
    "'"      #'edit-indirect-commit
    "C-c '"  (rasen/hard-way "'"))
  (general-def 'insert markdown-mode-map
    "C-c ,"  #'rasen/insert-timestamp)

  (setq markdown-fontify-code-blocks-natively t))
#+end_src

Package edit-indirect needed to edit code blocks.
#+begin_src emacs-lisp
(use-package edit-indirect
  :after markdown-mode)
#+end_src

**** Markdown cliplink
(Uses org-cliplink.)

#+begin_src emacs-lisp
(defun rasen/md-link-transformer (url title)
  (if title
      (format "[%s](%s)"
              (org-cliplink-elide-string
               (org-cliplink-escape-html4
                (org-cliplink-title-for-url url title))
               org-cliplink-max-length)
              url)
    (format "<%s>" url)))

(defun rasen/md-cliplink ()
  "Takes a URL from the clipboard and inserts an markdown-mode link
with the title of a page found by the URL into the current
buffer"
  (interactive)
  (org-cliplink-insert-transformed-title (org-cliplink-clipboard-content)
                                         #'rasen/md-link-transformer))
#+end_src
**** WriteGood
See http://bnbeckwith.com/code/writegood-mode.html

#+begin_src emacs-lisp
(use-package writegood-mode
  :hook (markdown-mode . writegood-mode))
#+end_src
*** JSON
#+begin_src emacs-lisp
(use-package json-mode
  :mode "\\.json$")
#+end_src
*** YAML
#+begin_src emacs-lisp
(use-package yaml-mode
  :mode ("\\.\\(yml\\|yaml\\)$" . yaml-mode))
#+end_src
*** Jinja2
#+begin_src emacs-lisp
(use-package jinja2-mode
  :mode "\\.j2$")
#+end_src
*** Docker
(~<<nixos-section>>~)
#+name: nixos-section
#+begin_src nix
{
  virtualisation.docker.enable = true;
}
#+end_src

(emacs-lisp)
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile"
  :config
  (setq dockerfile-mode-command "env SUDO_ASKPASS=/usr/bin/ssh-askpass sudo -A docker"))
#+end_src
*** restclient
#+begin_src emacs-lisp
(use-package restclient
  :mode "\\.http$")
#+end_src
*** terraform
#+begin_src emacs-lisp
(use-package terraform-mode
  :mode "\\.tf$")
#+end_src
*** graphviz
#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :mode "\\.dot$"
  :config
  (setq graphviz-dot-view-command "dotty %s"))
#+end_src
*** protobuf
#+begin_src emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto$")
#+end_src
*** SQL
#+begin_src emacs-lisp
(use-package sql
  :commands (sql-mode
             sql-connect
             sql-oracle
             sql-sybase
             sql-informix
             sql-sqlite
             sql-mysql
             sql-solid
             sql-ingres
             sql-ms
             sql-postgres
             sql-interbase
             sql-db2
             sql-linter
             sql-vertica)
  :config
  (add-hook 'sql-mode-hook (lambda () (toggle-truncate-lines t))))
#+end_src
*** PlantUML
Install plantuml.
#+name: home-manager-section
#+begin_src nix
{
  home.packages = [ pkgs.plantuml ];
}
#+end_src

Emacs configuration.
#+begin_src emacs-lisp
(use-package plantuml-mode
  :config
  (setq plantuml-executable-path (executable-find "plantuml"))
  (setq plantuml-jar-path (expand-file-name "../lib/plantuml.jar" (file-name-directory (file-truename plantuml-executable-path))))
  (setq org-plantuml-jar-path plantuml-jar-path)

  (setq plantuml-default-exec-mode 'executable)
  (setq plantuml-exec-mode 'executable)

  (setenv "PLANTUML_LIMIT_SIZE" "8192")

  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src
* Look and Feel
** Remove the clutter
Hide menu, toolbar, scrollbar. (Goes to early-init to avoid flash of unstyled emacs.)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

Do not show startup screen. (emacs-lisp)
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src

Do not blink cursor. (emacs-lisp)
#+begin_src emacs-lisp
(blink-cursor-mode 0)
#+end_src

Draw block cursor as wide as the glyph under it.
For example, if a block cursor is over a tab, it will be drawn as wide as that tab on the display.
#+begin_src emacs-lisp
(setq-default x-stretch-cursor t)
#+end_src

Hightlight parentheses, show current column.
#+begin_src emacs-lisp
(show-paren-mode 1)
(column-number-mode 1)
#+end_src
** beacon-mode
Add a little bit of highlighting for the cursor when buffer scrolls or cursor jumps, so I don't lose it.
#+begin_src emacs-lisp
(use-package beacon
  :diminish beacon-mode
  :config

  ;; do not blink where beacon-mode plays badly
  (defun rasen/dont-blink-predicate ()
    (member major-mode '(notmuch-search-mode)))
  (add-hook 'beacon-dont-blink-predicates #'rasen/dont-blink-predicate)

  (beacon-mode 1))
#+end_src
** Fonts
I'm not a font guru, so I just stuffed a bunch of random fonts in here.

#+name: nixos-section
#+begin_src nix
{
  fonts = {
    fontconfig.enable = true;
    fontDir.enable = true;
    enableGhostscriptFonts = false;

    fonts = with pkgs; [
      pkgs.inconsolata
      pkgs.dejavu_fonts
      pkgs.source-code-pro
      pkgs.ubuntu_font_family
      pkgs.unifont
      pkgs.powerline-fonts
      pkgs.terminus_font
    ];
  };
}
#+end_src

For home-manager.
#+name: home-manager-section
#+begin_src nix
{
  fonts.fontconfig.enable = true;
  home.packages = [
    pkgs.inconsolata
    pkgs.dejavu_fonts
    pkgs.source-code-pro
    pkgs.ubuntu_font_family
    pkgs.unifont
    pkgs.powerline-fonts
    pkgs.terminus_font
  ];
}
#+end_src

Configure fonts in Emacs. (~.emacs.d/early-init.el~)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(defun rasen/font-exists-p (font)
  "Check if the FONT exists."
  (and (display-graphic-p) (not (null (x-list-fonts font)))))

(defun rasen/set-my-fonts ()
  (cond
   ((rasen/font-exists-p "Input") ; check for custom four-family font first
    (set-face-attribute 'fixed-pitch nil :family "Input" :height 65)
    (set-face-attribute 'default nil :family "Input" :height 65))
   ((rasen/font-exists-p "Input Mono")
    (set-face-attribute 'fixed-pitch nil :family "Input Mono" :height 65)
    (set-face-attribute 'default nil :family "Input Mono" :height 65))
   ((rasen/font-exists-p "Fira Code Retina")
    (set-face-attribute 'fixed-pitch nil :family "Fira Code Retina" :height 65)
    (set-face-attribute 'default nil :family "Fira Code Retina" :height 65))
   ((rasen/font-exists-p "Terminess Powerline")
    (set-face-attribute 'fixed-pitch nil :family "Terminess Powerline" :height 160)
    (set-face-attribute 'default nil :family "Terminess Powerline" :height 160))
   ((rasen/font-exists-p "Terminus")
    (set-face-attribute 'fixed-pitch nil :family "Terminus" :height 160)
    (set-face-attribute 'default nil :family "Terminus" :height 160)))

  (cond
   ((rasen/font-exists-p "Linux Libertine O")
    (set-face-attribute 'variable-pitch nil :family "Linux Libertine O" :height 90))
   ((rasen/font-exists-p "Vollkorn")
    (set-face-attribute 'variable-pitch nil :family "Vollkorn" :height 80))
   ((rasen/font-exists-p "DejaVu Sans")
    (set-face-attribute 'variable-pitch nil :family "DejaVu Sans"))))

(rasen/set-my-fonts)
#+end_src

Apply my font settings when new frame is created (useful when emacs is started in daemon mode). (~.emacs.d/early-init.el~)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(defun rasen/font-hook (frame)
  (select-frame frame)
  (rasen/set-my-fonts))

(add-hook 'after-make-frame-functions #'rasen/font-hook)
#+end_src
** Custom Input font
I like the following settings more than defaults. I also need a custom four-style family because Emacs confuses regular/medium weight otherwise. Use link specified in ~requireFile~ to download the font.
#+DOWNLOADED: screenshot @ 2020-04-09 22:27:21
#+ATTR_ORG: :width 360
[[file:./images/20200409192721-screenshot.png]]

(~<<flake-packages>>~)
#+name: flake-packages
#+begin_src nix
{
  # note it's a new attribute and does not override old one
  input-mono = (pkgs.input-fonts.overrideAttrs (old: {
    src = pkgs.requireFile {
      name = "Input-Font.zip";
      url = "https://input.fontbureau.com/download/index.html?customize&fontSelection=fourStyleFamily&regular=InputMonoNarrow-Regular&italic=InputMonoNarrow-Italic&bold=InputMonoNarrow-Bold&boldItalic=InputMonoNarrow-BoldItalic&a=0&g=0&i=topserif&l=serifs_round&zero=0&asterisk=height&braces=straight&preset=default&line-height=1.2&email=";
      sha256 = "0nn41w2b6jvsbr3r4lfy4p8w2ssjmgdjzd1pbj7p0vmawjpvx2w8";
    };
    outputHash = "1w2i660dg04nyc6fc6r6sd3pw53h8dh8yx4iy6ccpii9gwjl9val";
  }));
}
#+end_src
** Variable-pitch fonts in org-mode
Use variable-pitch fonts in org-mode. (~<<org-config>>~)
#+name: org-config
#+begin_src emacs-lisp
(push "~/.emacs.d/site-lisp" load-path)
(require 'org-variable-pitch)
(setq org-variable-pitch-fixed-font "Input")
(set-face-attribute 'org-variable-pitch-fixed-face nil :height 65)
(set-face-attribute 'org-variable-pitch-fixed-face nil :weight 'regular)
(diminish 'org-variable-pitch-minor-mode)
(diminish 'buffer-face-mode)

;; Because asterisk in variable-pitch font is way too high, fontify
;; leading asterisks with fixed pitch face instead.
(setq org-variable-pitch-fontify-headline-prefix t)

(add-hook 'org-mode-hook #'org-variable-pitch-minor-mode)
#+end_src

Patch adaptive-wrap, so it work better with org-variable-pitch-mode (i.e., make adaptive prefix fixed-pitch).
#+begin_src emacs-lisp
(el-patch-defun adaptive-wrap-prefix-function (beg end)
  "Indent the region between BEG and END with adaptive filling."
  ;; Any change at the beginning of a line might change its wrap prefix, which
  ;; affects the whole line.  So we need to "round-up" `end' to the nearest end
  ;; of line.  We do the same with `beg' although it's probably not needed.
  (goto-char end)
  (unless (bolp) (forward-line 1))
  (setq end (point))
  (goto-char beg)
  (forward-line 0)
  (setq beg (point))
  (while (< (point) end)
    (let ((lbp (point)))
      (put-text-property
       (point) (progn (search-forward "\n" end 'move) (point))
       'wrap-prefix
       (let ((pfx (adaptive-wrap-fill-context-prefix
                   lbp (point))))
         ;; Remove any `wrap-prefix' property that
         ;; might have been added earlier.
         ;; Otherwise, we end up with a string
         ;; containing a `wrap-prefix' string
         ;; containing a `wrap-prefix' string ...
         (remove-text-properties
          0 (length pfx) '(wrap-prefix) pfx)
         (let ((dp (get-text-property 0 'display pfx)))
           (when (and dp (eq dp (get-text-property (1- lbp) 'display)))
             ;; There's a `display' property which covers not just the
             ;; prefix but also the previous newline.  So it's not just making
             ;; the prefix more pretty and could interfere or even defeat our
             ;; efforts (e.g. it comes from `visual-fill-mode').
             (remove-text-properties
              0 (length pfx) '(display) pfx)))

         (el-patch-add
           (add-face-text-property 0 (length pfx) 'org-variable-pitch-fixed-face nil pfx))

         pfx))))
  `(jit-lock-bounds ,beg . ,end))
#+end_src
** Hi-DPI
These are for omicron-only.

#+name: home-manager-section
#+begin_src nix
{
  xresources.properties = {
    "Xft.dpi" = 276;
    "Xcursor.size" = 64;
  };
}
#+end_src

#+name: machine-omicron
#+begin_src nix
{
  console.packages = [
    pkgs.terminus_font
  ];
  console.font = "ter-132n";
}
#+end_src

#+name: machine-omicron
#+begin_src nix
{
  services.xserver.dpi = 276;
}
#+end_src
** Color theme
I use [[https://gitlab.com/protesilaos/modus-themes][modus-operandi]] theme. (Goes to early-init to avoid flash of unstyled emacs.)
#+begin_src emacs-lisp :tangle .emacs.d/early-init.el
(require 'modus-themes-core)
(require 'modus-operandi-theme)

(setq modus-operandi-theme-slanted-constructs t)
(setq modus-operandi-theme-bold-constructs t)

;; Use proportional fonts only when I explicitly configure them.
(setq modus-operandi-theme-proportional-fonts nil)

(defmacro with-modus-colors (name &rest cmds)
  "Bind NAME's color palette around face specifications.

NAME should be the proper name of a Modus theme, either
'modus-operandi or 'modus-vivendi."
  (declare (indent defun))
  (let ((faces modus-themes-faces)
        (cus modus-themes-custom-variables))
    `(let ((class '((class color) (min-colors 89)))
           ,@(mapcar (lambda (cons)
                       `(,(car cons) ,(cdr cons)))
                     (modus-themes-core-theme-variables name)))
       ,@cmds)))

(load-theme 'modus-operandi t)

(with-modus-colors 'modus-operandi
  (let ((custom--inhibit-theme-enable nil))
    (custom-theme-set-faces
     'modus-operandi

     `(vterm-color-default ((,class (:background ,bg-main :foreground ,fg-main))))
     `(vterm-color-black ((,class (:background "#000" :foreground "#000"))))
     `(vterm-color-white ((,class (:background "#fff" :foreground "#fff"))))
     `(vterm-color-red ((,class (:background ,red-intense-bg :foreground ,red))))
     `(vterm-color-green ((,class (:background ,green-intense-bg :foreground ,green))))
     `(vterm-color-yellow ((,class (:background ,yellow-intense-bg :foreground ,yellow))))
     `(vterm-color-blue ((,class (:background ,blue-intense-bg :foreground ,blue))))
     `(vterm-color-magenta ((,class (:background ,magenta-intense-bg :foreground ,magenta))))
     `(vterm-color-cyan ((,class (:background ,cyan-intense-bg :foreground ,cyan))))

     ;; do not bold matches (this makes text jiggle with variable-pitch fonts
     `(isearch ((,class (:inherit modus-theme-intense-green))))
     `(query-replace ((,class :inherit modus-theme-intense-yellow)))
     ;; `(show-paren-match ((,class (:background ,bg-paren-match :foreground ,fg-main))))

     ;; do not change background/foreground — just add wiggly line
     `(flyspell-duplicate
       ((,(append '((supports :underline (:style wave))) class)
         (:underline (:style wave :color ,yellow)))
        (,class (:underline ,yellow))))
     `(flyspell-incorrect
       ((,(append '((supports :underline (:style wave))) class)
         (:underline (:style wave :color ,red)))
        (,class (:underline ,red))))

     ;; do not change foreground for italics
     `(italic ((,class :slant italic)))

     ;; Make TODOs bold
     `(org-todo ((,class :foreground ,magenta-alt-other
                         :weight bold)))
     `(org-archived ((,class (:foreground ,fg-alt))))
     `(org-done ((,class :foreground ,fg-alt)))
     `(org-headline-done ((,class :foreground ,fg-alt)))
     `(org-agenda-done ((,class :foreground ,fg-alt)))
     `(org-date ((,class :foreground ,cyan-alt :underline nil)))

     `(org-link ((,class :foreground ,blue-alt :background ,bg-alt :underline nil :inherit link)))
     `(org-roam-link ((,class :foreground ,green-alt :inherit org-link)))))

  (setq org-todo-keyword-faces
        `(("TODO"     . (:foreground ,blue-intense :inherit fixed-pitch))
          ("NEXT"     . (:foreground ,red-intense  :inherit fixed-pitch))
          ("BUILD"    . (:foreground ,red-intense  :inherit fixed-pitch))
          ("WAIT"     . (:foreground ,magenta-alt  :inherit fixed-pitch))
          ("DONE"     . (:foreground ,fg-alt       :inherit fixed-pitch))
          ("CANCELED" . (:foreground ,fg-alt       :inherit fixed-pitch)))))
#+end_src
** Emacs modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :config
  (setq doom-modeline-icon nil)
  (doom-modeline-mode 1))
#+end_src

Display time and battery level in modeline.
#+begin_src emacs-lisp
(use-package time
  ;; builtin
  :config
  (setq display-time-default-load-average nil)
  (setq display-time-24hr-format t)
  (display-time-mode 1))

(use-package battery
  ;; builtin
  :config
  (display-battery-mode 1))
#+end_src
* Misc
#+name: home-manager-section
#+begin_src nix
{
  home.file = {
    ".nethackrc".source = ./.nethackrc;
  };

  programs.fish.shellInit = ''
    set -x PATH ${./bin} $PATH
  '';
}
#+end_src

** goto config
The following provides key binding to quickly open my configuration file.

#+begin_src emacs-lisp
(defun rasen/find-config ()
  (interactive)
  (find-file (expand-file-name "README.org" rasen/dotfiles-directory)))

(general-def
  "<f12>" #'rasen/find-config)

(rasen/exwm-input-set-key (kbd "<s-f12>") #'rasen/find-config)
#+end_src
** Configure PATH
Set PATH env variable from =exec-path=. This is required for =shell-command= to find executables available in =exec-path=. (Most notably, org-mode latex preview fails without this.)
#+begin_src emacs-lisp
(setenv "PATH" (string-join exec-path ":"))
#+end_src
